.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Smart 3pm"
.TH Smart 3pm "2007-06-26" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
IPC::Smart \- Shm interface to talk between parent and daughter processes
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use IPC::Smart;
.Ve
.PP
.Vb 9
\&  $share = new IPC::Smart(\-size=>100) or die $!;
\&  $share\->store("This is stored in shared memory");
\&  $str = $share\->fetch;
\&  if (fork()==0){
\&     # in the daughter
\&     $share\->store("This is my verbose message");
\&  }
\&  sleep(1);
\&  printf("Message from process=%s\en",$share\->fetch);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
IPC::Smart provides a very smart interface to shared memory, allowing
data to be efficiently communicated between processes.  It is derived
from the module IPC::ShareLite.
.PP
System must support SysV \s-1IPC\s0 (shared memory and semaphores) in order to 
use this module.
.PP
IPC::Smart provides an abstraction of the shared memory and
semaphore facilities of SysV \s-1IPC\s0, allowing the storage of arbitrarily
large data; the module automatically acquires and removes shared memory
segments as needed.  Storage and retrieval of data is atomic, and
locking functions are provided for higher-level synchronization.
.PP
In many respects, this module is similar to IPC::Shareable.  However,
IPC::Smart does not provide a tied interface, does not 
(automatically) allow the storage of variables, and is written in C
for additional speed.
.PP
Construct an IPC::Smart object by calling its constructor:
.PP
.Vb 1
\&        $share = new IPC::Smart( \-size=> 1024) or die $!;
.Ve
.PP
Once an instance has been created, data can be written to shared memory
by calling the \fIstore()\fR method:
.PP
.Vb 1
\&        $share\->store("This is going in shared memory");
.Ve
.PP
Retrieve the data by calling the \fIfetch()\fR method:
.PP
.Vb 1
\&        $str = $share\->fetch();
.Ve
.PP
The \fIstore()\fR and \fIfetch()\fR methods are atomic; any processes attempting
to read or write to the memory are blocked until these calls finish.
However, in certain situations, you'll want to perform multiple
operations atomically.  Advisory locking methods are available for 
this purpose.
.PP
An exclusive lock is obtained by calling the \fIlock()\fR method:
.PP
.Vb 1
\&        $share\->lock();
.Ve
.PP
Happily, the \fIlock()\fR method also accepts all of the flags recognized
by the \fIflock()\fR system call.  So, for example, you can obtain a
shared lock like this:
.PP
.Vb 1
\&        $share\->lock( LOCK_SH );
.Ve
.PP
Or, you can make either type of lock non\-blocking:
.PP
.Vb 1
\&        $share\->lock( LOCK_EX|LOCK_NB );
.Ve
.PP
Release the lock by calling the \fIunlock()\fR method:
.PP
.Vb 1
\&        $share\->unlock;
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "new($size)" 4
.IX Item "new($size)"
This is the constructor for IPC::Smart.  It accepts both 
the positional and named parameter calling styles.
.Sp
$size specifies the shared memory segment size, in bytes.
The default size is 65,536 bytes, which is fairly portable.  
Linux, as an example, supports segment sizes of 4 megabytes.
.Sp
The constructor returns the undefined value on error.
.ie n .IP "store( $scalar )" 4
.el .IP "store( \f(CW$scalar\fR )" 4
.IX Item "store( $scalar )"
This method stores \f(CW$scalar\fR into shared memory.  \f(CW$scalar\fR may be
arbitrarily long.  Shared memory segments are acquired and
released automatically as the data length changes.
The only limits on the amount of data are the system-wide
limits on shared memory pages (\s-1SHMALL\s0) and segments (\s-1SHMMNI\s0)
as compiled into the kernel. 
.Sp
Note that unlike IPC::Shareable, this module does not automatically
allow variables to be stored.  Serializing all data is expensive, and
is not always necessary.  If you need to store a variable, you should
employ the Storable module yourself.  For example:
.Sp
.Vb 6
\&        use Storable qw( freeze thaw );
\&        ...
\&        $hash = { red => 1, white => 1, blue => 1 };
\&        $share\->store( freeze( $hash ) );
\&        ...
\&        $hash = thaw( $share\->fetch );
.Ve
.Sp
The method raises an exception on error.
.IP "\fIfetch()\fR" 4
.IX Item "fetch()"
This method returns the data that was previously stored in
shared memory.  The empty string is returned if no data was
previously stored.
.Sp
The method raises an exception on error.
.ie n .IP "lock( $type )" 4
.el .IP "lock( \f(CW$type\fR )" 4
.IX Item "lock( $type )"
Obtains a lock on the shared memory.  \f(CW$type\fR specifies the type
of lock to acquire.  If \f(CW$type\fR is not specified, an exclusive
read/write lock is obtained.  Acceptable values for \f(CW$type\fR are
the same as for the \fIflock()\fR system call.  The method returns
true on success, and undef on error.  For non-blocking calls
(see below), the method returns 0 if it would have blocked.
.Sp
Obtain an exclusive lock like this:
.Sp
.Vb 1
\&        $share\->lock( LOCK_EX ); # same as default
.Ve
.Sp
Only one process can hold an exclusive lock on the shared memory at
a given time.
.Sp
Obtain a shared lock this this:
.Sp
.Vb 1
\&        $share\->lock( LOCK_SH );
.Ve
.Sp
Multiple processes can hold a shared lock at a given time.  If a process
attempts to obtain an exclusive lock while one or more processes hold
shared locks, it will be blocked until they have all finished.
.Sp
Either of the locks may be specified as non\-blocking:
.Sp
.Vb 2
\&        $share\->lock( LOCK_EX|LOCK_NB );
\&        $share\->lock( LOCK_SH|LOCK_NB );
.Ve
.Sp
A non-blocking lock request will return 0 if it would have had to
wait to obtain the lock.    
.Sp
Note that these locks are advisory (just like flock), meaning that
all cooperating processes must coordinate their accesses to shared memory
using these calls in order for locking to work.  See the \fIflock()\fR call for 
details.
.Sp
Locks are inherited through forks, which means that two processes actually
can possess an exclusive lock at the same time.  Don't do that.
.Sp
The constants \s-1LOCK_EX\s0, \s-1LOCK_SH\s0, \s-1LOCK_NB\s0, and \s-1LOCK_UN\s0 are available
for import:
.Sp
.Vb 1
\&        use IPC::Smart qw( :lock );
.Ve
.Sp
Or, just use the flock constants available in the Fcntl module.
.IP "\fIunlock()\fR" 4
.IX Item "unlock()"
Releases any locks.  This is actually equivalent to:
.Sp
.Vb 1
\&        $share\->lock( LOCK_UN );
.Ve
.Sp
The method returns true on success and undef on error.
.SH "PERFORMANCE"
.IX Header "PERFORMANCE"
For a rough idea of the performance you can expect, here are some
benchmarks.  The tests were performed using the Benchmark module
on a Cyrix \s-1PR166+\s0 running RedHat Linux 5.2 with the 2.0.36 kernel,
perl 5.005_02 using perl's malloc, and the default shared memory
segment size.  Each test was run 5000 times.
.PP
.Vb 1
\&        DATA SIZE (bytes)       TIME (seconds)  Op/Sec
.Ve
.PP
.Vb 2
\& store  16384                   2               2500
\& fetch  16384                   2               2500
.Ve
.PP
.Vb 2
\& store  32768                   3               1666    
\& fetch  32768                   3               1666
.Ve
.PP
.Vb 2
\& store  65536                   6               833
\& fetch  65536                   5               1000
.Ve
.PP
.Vb 2
\& store  131072                  12              416     
\& fetch  131072                  12              416
.Ve
.PP
.Vb 2
\& store  262144                  28              178     
\& fetch  262144                  27              185
.Ve
.PP
.Vb 2
\& store  524288                  63              79      
\& fetch  524288                  61              81
.Ve
.PP
Most of the time appears to be due to memory copying.  
Suggestions for speed improvements are welcome.
.SH "PORTABILITY"
.IX Header "PORTABILITY"
The module should compile on any system with SysV \s-1IPC\s0 and
an \s-1ANSI\s0 C compiler, and should compile cleanly with the
\&\-pedantic and \-Wall flags.
.PP
The module has been tested under Solaris, FreeBSD, and Linux.
Testing on other platforms is needed.  
.PP
If you encounter a compilation error due to the definition
of the semun union, edit the top of smart.c and undefine
the semun definition.  And then please tell me about it.
.PP
I've heard rumors that a SysV \s-1IPC\s0 interface has been 
constructed for Win32 systems.  Support for it may be
added to this module.
.PP
IPC::Smart does not understand the shared memory
data format used by IPC::Shareable.  
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright 1998\-2002, Maurice Aubrey <maurice@hevanet.com>. 
All rights reserved.
.PP
This module is free software; you may redistribute it and/or
modify it under the same terms as Perl itself. 
.SH "CREDITS"
.IX Header "CREDITS"
Special thanks to Benjamin Sugars for developing the IPC::Shareable
module.
.PP
See the Changes file for other contributors.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
IPC::Shareable, \fIipc\fR\|(2), \fIshmget\fR\|(2), \fIsemget\fR\|(2), perl.
