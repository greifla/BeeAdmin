#!/usr/bin/perl
use lib qw( /opt/w5base/lib);
use strict;                   
use W5Base::API;
use Data::Dumper;
use Net::DNS;
use Fcntl qw(SEEK_SET);

my $DefaultBase="https://w5base.net/w5base/auth/";
my ($help,$verbose,$loginuser,$loginpass,$quiet,$base,$lang);
my ($mode,$force,$hostname,$type);
my %o;
my $count=0;
my %P=("help"=>\$help,"base=s"=>\$base,"lang=s"=>\$lang,
       "webuser=s"=>\$loginuser,"webpass=s"=> \$loginpass,
       "verbose+"=>\$verbose,
       "force"=>\$force,"hostname=s"=>\$hostname,
       "mode=s"=>\$mode,"type=s"=>\$type);
my @allowedmodes=qw(auto emc netapp);
my $optresult=XGetOptions(\%P,\&Help,undef,undef,".W5Base.Interface");
my $netdns=new Net::DNS::Resolver();

$mode="auto" if (!defined($mode));
$type="nfs" if (!defined($type));

my @hostname=split(/,/,$hostname);
if ($#ARGV != $#hostname){
   msg(ERROR,"number of files and hostnames must be the same!");
   exit(1);
}

# create connection config
my $apidebug=$verbose>=3 ? 1 : 0;
my $Config=createConfig($base,$loginuser,$loginpass,$lang,$apidebug);
if (!defined($Config)){
   msg(ERROR,"base or username/password is not valid");exit(1);
}
else{
   msg(DEBUG,"create of config ok");
}
msg(DEBUG,"verbose=$verbose");


# load ModuleObject
my %loadobj=('sys'=>'itil::system',
             'nas'=>'itil::systemnfsnas',
             'net'=>'itil::network',
             'ipnet'=>'itil::lnknfsnasipnet');
foreach my $localid (keys(%loadobj)){
   my $objectname=$loadobj{$localid};
   my $obj=getModuleObject($Config,$objectname);
   if (!defined($obj)){
      msg(ERROR,"can't load object $objectname");exit(2);
   }else{
      msg(DEBUG,"create of ModuleObject $objectname ok");
   }
   $o{$localid}=$obj;
}

foreach my $file (@ARGV){
   if (open(FILE,"<$file")){ 
      my $curmode=$mode;
      $curmode=detectMode(\*FILE) if ($mode eq "auto");
      msg(DEBUG,"curmode=$curmode");
      my %sharedata;
      my $result=readFile(\*FILE,\%sharedata,$curmode,$hostname[$count]);
      exit(1) if ($result != 0);
      my @oplist;
      my $result=calculateOperations(\%o,\%sharedata,\@oplist,$hostname[$count]);
      exit(1) if ($result != 0);
      if ($force){
         my $result=processOperations(\%o,\@oplist);
         exit(1) if ($result != 0);
      }else{
         foreach my $record (@oplist){
            msg(INFO,$record->{MSG});
         }
      }
      close(FILE);
   }else{
      msg(ERROR,"file not exists!");
      exit(1);
   }
   $count++;
}


sub detectMode
{
   my $fh=shift;
   my $mode;
   while(<$fh>){
      if ($_=~m/^export.*$/){
         $mode="emc";
         return($mode);
      }elsif($_=~m/^.*sec=sys.*$/){
         $mode="netapp";
         return($mode);
      }
   }
   msg(ERROR,"mode not exists");
   return(1);
}



sub readFile
{
   my $fh=shift;
   my $sharedata=shift;
   my $cm=shift;
   my $hostname=shift;
   seek($fh,SEEK_SET,0);
   while(my $line=<$fh>){
      $line=~s/\s*$//;
      $line=~s/#.*$//;
      next if ($line=~m/^\s*#.*$/);
      next if ($line=~m/^\s*$/);
      my ($path,$param,@param);
      if ($cm eq "netapp"){
         if (($path,$param)=$line=~m/^(\/.*)\s+(.*)\s*$/){
            $param=~s/^-//;
            @param=split(/,/,$param); 
         }else{
            msg(WARN,"line ignored: ".$line);
         }
      }elsif($cm eq "emc"){
         if (($path,$param)=$line=~m/^export\s+"([^"]+)"\s+(.*)\s*$/){
             @param=split(/\s+/,$param); 
         }else{
            msg(WARN,"line ignored: ".$line);
         }
      }
      foreach my $param (@param){
         if (my ($var,$ip)=$param=~m/^(\S+)=(.*)\s*$/){
            if (lc($var) ne "access" and lc($var) ne 
                         "rw" and lc($var) ne "root"){
               $sharedata->{$hostname}->{$path}->{'exportoptions'}="$ip=$var ";
               next;
            }
            foreach my $ip (split(/:/,$ip)){
               if ($ip!~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+.*$/){
                  my $query;
                  if ($query=$netdns->search($ip)){
                     foreach my $rr ($query->answer) {
                        next unless $rr->type eq "A";
                        $ip=$rr->address;
                     }
                  }else{
                     $sharedata->{$hostname}->{$path}->{'exportoptions'}=
                     $sharedata->{$hostname}->{$path}->{'exportoptions'}.
                     "$var=$ip ";
                     msg(WARN,"unknown IP/HOST=$ip, 
                               entry will be a export option!");
                     next;
                  }
               }
               if ($ip!~m/^.*[\/].*$/ and 
                   $ip=~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/){
                  $ip="$ip/32";
               }
               $sharedata->{$hostname}->{$path}->{'ip'}->{$ip}->{$var}=1;
            }
         }
         else{
            msg(WARN,"param problem $param line=$line");
         }
      }
   }
   return(0);
}


sub calculateOperations
{
   my $o=shift;    
   my $sharedata=shift;    
   my $oplist=shift;    
   my $hostname=shift;    
   my ($networkid,$found);

   # get hostname
   $o->{'sys'}->SetFilter({name=>$hostname});
   my @hl=$o->{'sys'}->getHashList(qw(id));
   if ($#hl==-1){
      $o->{'sys'}->LastMsg();
#      msg(ERROR,"system $hostname not exists!");
      return(1);      
   }
   if ($#hl>0){
      $o->{'sys'}->LastMsg();
#      msg(ERROR,"system $hostname not unique!");
      return(1);      
   }
  
   # get network 
   $o->{'net'}->SetFilter({name=>['T-Systems Storage/NAS LAN']});
   my @netid=$o->{'net'}->getHashList(qw(id));
   if ($#netid==-1){
      $o->{'sys'}->LastMsg();
  #    msg(ERROR,"network T-Systems Storage/NAS LAN not exists!");
      return(1);      
   }
   if ($#netid>0){
      $o->{'sys'}->LastMsg();
  #    msg(ERROR,"network T-Systems Storage/NAS LAN not unique!");
      return(1);      
   }

   # get available shares
   my $destid=$hl[0]->{id};
   $o->{'nas'}->SetFilter({systemid=>$destid});
   my @ln=$o->{'nas'}->getHashList(qw(id systemnfsnasserver name cistatusid
                                      type exportoptions systemnfsnas system));
   $o->{'nas'}->dieOnERROR();
   # set needless shares on delete state
   foreach my $ln (@ln){
      my $found=0;
      foreach my $share (keys(%{$sharedata->{$hostname}})){
         if ($ln->{name} eq $share){
            $found=1;
         }
      } 
      if ($found == 0){
          push(@$oplist,{OP           => 'update',
                         DATAOBJALIAS => 'nas',
                         IDENTIFYBY   => $ln->{id},
                         MSG          => "delete share ".$ln->{name},
                         DATA         => {cistatusid => 6}});
      }
   }

   foreach my $share (keys(%{$sharedata->{$hostname}})){
      my $ref;
      my $mode="insert";
      foreach my $ln (@ln){
         if ($ln->{name} eq $share){
            $mode="update";
            if ($ln->{cistatusid} != 4 or $ln->{type} ne $type){
               push(@$oplist,{OP           => 'update',
                              DATAOBJALIAS => 'nas',
                              IDENTIFYBY   => $ln->{id},
                              MSG          => "update $share on $hostname",
                              DATA         => {
                                type          => $type,
                                cistatusid    => 4,
                                hostname      => $hostname,
                                name          => $share}});
            }
            # get available ip's
            $o->{'ipnet'}->SetFilter({systemnfsnasid=>$ln->{id}});
            my @ni=$o->{'ipnet'}->getHashList(qw(id exportoptions 
                                              networkid systemnfsnasid name));
            $o->{'ipnet'}->dieOnERROR();
            # delete ip's on a existing share
            foreach my $ni (@ni){
               $found=0;
               foreach my $ip (keys(%{$sharedata->{$hostname}->
                                      {$share}->{ip}})){
                  if ($ni->{name} eq $ip){ 
                     $found=1;
                  } 
               }
               if ($found == 0){
                  push(@$oplist,{OP           => 'delete',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => $ni->{id},
                                 MSG          => "delete ip with id=$found",
                                 DATA         => {}});
               }
            }
            # update or insert ip's on a existing share
            foreach my $ip (keys(%{$sharedata->{$hostname}->{$share}->{ip}})){
               $found=0;
               my $options;
               foreach my $ni (@ni){
                  my @r;
                  foreach my $rights (keys(%{$sharedata->{$hostname}->
                                              {$share}->{ip}->{$ip}})){
                        if ($sharedata->{$hostname}->{$share}->
                                         {ip}->{$ip}->{$rights} == 1){
                           push(@r,$rights);     
                        }
                  }
                  $options=join(",",@r);
                  if ($ni->{name} eq $ip and ($ni->{networkid} ne $netid[0]->{id} or
                     $ni->{exportoptions} ne $options or 
                     $ni->{systemnfsnasid} ne $ln->{id})){
                      $found=$ni->{id};
                  }elsif($ni->{name} eq $ip){
                      $found=2;
                  }
               }
               if ($found == 0){
                  push(@$oplist,{OP           => 'insert',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => undef,
                                 MSG          => "insert ip $ip",
                                 DATA         => {
                                   systemnfsnasid  => $ln->{id},
                                   exportoptions   => $options,
                                   name            => $ip,
                                   networkid       => $netid[0]->{id}}});
               }elsif($found != 2){
                  push(@$oplist,{OP           => 'update',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => $found,
                                 MSG          => "update ip $ip",
                                 DATA         => {
                                   systemnfsnasid  => $ln->{id},
                                   exportoptions   => $options,
                                   name            => $ip,
                                   networkid       => $netid[0]->{id}}});
               }
            }
         }
      }
      # insert a new share
      if ($mode eq "insert"){
         my $newshare={OP           => 'insert',
                       DATAOBJALIAS => 'nas',
                       IDENTIFYBY   => undef,
                       MSG          => "insert $share on $hostname", 
                       DATA         => {
                         type          => $type,
                         cistatusid    => 4,
                         system        => $hostname,
                         name          => $share,
                         exportoptions => $sharedata->{$hostname}->{$share}->
                                          {'exportoptions'}}};
 
         push(@$oplist,$newshare);

         # insert a new ip on a new share
         my $options;
         foreach my $ip (keys(%{$sharedata->{$hostname}->{$share}->{ip}})){
            my @r;
            foreach my $rights (keys(%{$sharedata->{$hostname}->
                                       {$share}->{ip}->{$ip}})){
               if ($sharedata->{$hostname}->{$share}->{ip}->
                   {$ip}->{$rights} == 1){
                  push(@r,$rights);     
               }
            }
            $options=join(",",@r);
            push(@$oplist,{OP           => 'insert',
                           DATAOBJALIAS => 'ipnet',
                           IDENTIFYBY   => undef,
                           MSG          => "insert ip $ip on $hostname", 
                           DATA         => {
                             name            => $ip,
                             networkid       => $netid[0]->{id},
                             exportoptions   => $options,
                             systemnfsnasid  => \$newshare->{IDENTIFYBY}}});
         }
      }
   }
   return(0);
}


sub processOperations
{
   my $o=shift;    
   my $oplist=shift;    
   my ($id,$found);

   foreach my $record (@$oplist){
      # check for valid objects only
      foreach my $objname (keys(%{$record})){
         $found=0;
         foreach my $orgobjname (qw(DATAOBJALIAS OP MSG DATA IDENTIFYBY)){
            $found=1 if ($objname eq $orgobjname);
         }
         if ($found == 0){
            msg(ERROR,"Objectname=$objname not allowed");
            return(1);
         }
      }
      foreach my $data (keys(%{$record->{'DATA'}})){
         if (ref($record->{'DATA'}->{$data}) eq "SCALAR"){ 
            $record->{'DATA'}->{$data}=${$record->{'DATA'}->{$data}};
         }
      }
      if ($record->{OP} eq "insert"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->storeRecord($record->{'DATA'});
         $record->{'IDENTIFYBY'}=$id;
      }elsif($record->{OP} eq "update"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->storeRecord($record->{'DATA'},
                                                          $record->{'IDENTIFYBY'});
      }elsif($record->{OP} eq "delete"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->deleteRecord($record->{'IDENTIFYBY'});
printf ("fifi delete=%s\n",$record->{'IDENTIFYBY'});
      }else{
         msg(ERROR,"unvalid mode ".$record->{OP});
         return(1);
      }
      $o->{$record->{'DATAOBJALIAS'}}->dieOnERROR();
      msg(INFO,$record->{MSG});
   }
}


my $flt=$ARGV[0];
if ($flt eq ""){
   msg(ERROR,"no filter specified");exit(3);
}


# help menu
sub Help
{
   print(<<EOF);
$RealScript [options] File File ...

   --verbose  display more details of operation process
   --quiet    only errors would be displayed
   --base     base url of filemgmt (default: $DefaultBase)
   --webuser  username
   --webpass  password
   --store    stores the parameters (not help,verbose and store)
   --help     show this help
              
   --mode     emc, netapp, auto if no --mode
   --hostname more than one seperate by comma
   --type     export type (nfs, cifs ...)
   --force    
EOF
}

exit(255);
