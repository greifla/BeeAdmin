#!/usr/bin/perl
use lib qw( /opt/w5base/lib);
use strict;                   
use W5Base::API;
use Data::Dumper;
use Net::DNS;
use Fcntl qw(SEEK_SET);

my $DefaultBase="https://w5base.net/w5base/auth/";
my ($help,$verbose,$loginuser,$loginpass,$quiet,$base,$lang);
my ($mode,$force,$hostname,$type);
my %o;
my $count=0;
my %P=("help"=>\$help,"base=s"=>\$base,"lang=s"=>\$lang,
       "webuser=s"=>\$loginuser,"webpass=s"=> \$loginpass,
       "verbose+"=>\$verbose,
       "force"=>\$force,"hostname=s"=>\$hostname,
       "mode=s"=>\$mode,"type=s"=>\$type);
my @allowedmodes=qw(auto emc netapp);
my $optresult=XGetOptions(\%P,\&Help,undef,undef,".W5Base.Interface");
my $netdns=new Net::DNS::Resolver();

$mode="auto" if (!defined($mode));
$type="nfs" if (!defined($type));

my @hostname=split(/,/,$hostname);
if ($#ARGV != $#hostname){
   msg(ERROR,"number of files and hostnames must be the same!");
   exit(1);
}

#######################################################################
# create connection config
#
my $apidebug=$verbose>=3 ? 1 : 0;
my $Config=createConfig($base,$loginuser,$loginpass,$lang,$apidebug);
if (!defined($Config)){
   msg(ERROR,"base or username/password is not valid");exit(1);
}
else{
   msg(DEBUG,"create of config ok");
}
msg(DEBUG,"verbose=$verbose");


#
# Datenobjecte laden
#
#
#######################################################################
# load ModuleObject
#
my %loadobj=('sys'=>'itil::system',
             'nas'=>'itil::systemnfsnas',
             'net'=>'itil::network',
             'ipnet'=>'itil::lnknfsnasipnet');
foreach my $localid (keys(%loadobj)){
   my $objectname=$loadobj{$localid};
   my $obj=getModuleObject($Config,$objectname);
   if (!defined($obj)){
      msg(ERROR,"can't load object $objectname");exit(2);
   }else{
      msg(DEBUG,"create of ModuleObject $objectname ok");
   }
   $o{$localid}=$obj;
}

foreach my $file (@ARGV){
   if (open(FILE,"<$file")){ 
      my $curmode=$mode;
      $curmode=detectMode(\*FILE) if ($mode eq "auto");
      msg(DEBUG,"curmode=$curmode");
      my %sharedata;
      my $result=readFile(\*FILE,\%sharedata,$curmode,$hostname[$count]);
      exit(1) if ($result != 0);
      my @oplist;
      my $result=calculateOperations(\%o,\%sharedata,\@oplist,$hostname[$count]); 
      exit(1) if ($result != 0);
      if ($force){
         my $result=processOperations(\%o,\@oplist);
         exit(1) if ($result != 0);
      }else{
         foreach my $preview (@oplist){
            msg(INFO,$preview->{'op'}." ".$preview->{'export'});
         }
      }
      close(FILE);
   }
   $count++;
}



sub detectMode
{
   my $fh=shift;
   my $mode;
   while(<$fh>){
      if ($_=~m/^export.*$/){
         $mode="emc";
      }elsif($_=~m/^.*sec=sys.*$/){
         $mode="netapp";
      }
   }
   return($mode);
}



sub readFile
{
   my $fh=shift;
   my $sharedata=shift;
   my $cm=shift;
   my $hostname=shift;
   seek($fh,SEEK_SET,0);
   while(my $line=<$fh>){
      $line=~s/\s*$//;
      $line=~s/#.*$//;
      next if ($line=~m/^\s*#.*$/);
      next if ($line=~m/^\s*$/);
      my ($path,$param,@param);
      if ($cm eq "netapp"){
         if (($path,$param)=$line=~m/^(\/.*)\s+(.*)\s*$/){
            $param=~s/^-//;
            @param=split(/,/,$param); 
         }else{
            msg(WARN,"line ignored: ".$line);
         }
      }elsif($cm eq "emc"){
         if (($path,$param)=$line=~m/^export\s+"([^"]+)"\s+(.*)\s*$/){
             @param=split(/\s+/,$param); 
         }else{
            msg(WARN,"line ignored: ".$line);
         }
      }
      foreach my $param (@param){
         if (my ($var,$ip)=$param=~m/^(\S+)=(.*)\s*$/){
            if (lc($var) ne "access" and lc($var) ne "rw" and lc($var) ne "root"){
               $sharedata->{$hostname}->{$path}->{'exportoptions'}="$ip=$var ";
               next;
            }
            foreach my $ip (split(/:/,$ip)){
               if ($ip!~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+.*$/){
                  my $query;
                  if ($query=$netdns->search($ip)){
                     foreach my $rr ($query->answer) {
                        next unless $rr->type eq "A";
                        $ip=$rr->address;
                     }
                  }else{
                     $sharedata->{$hostname}->{$path}->{'exportoptions'}=
                     $sharedata->{$hostname}->{$path}->{'exportoptions'}."$var=$ip ";
                     msg(WARN,"unknown IP/HOST=$ip, entry will be a export option!");
                     next;
                  }
               }
               if ($ip!~m/^.*[\/].*$/ and $ip=~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/){
                  $ip="$ip/32";
               }
               $sharedata->{$hostname}->{$path}->{'ip'}->{$ip}->{$var}=1;
            }
         }
         else{
            msg(WARN,"param problem $param line=$line");
         }
      }
   }
   return(0);
}


sub calculateOperations
{
   my $o=shift;    
   my $sharedata=shift;    
   my $oplist=shift;    
   my $hostname=shift;    
   my $mode="insert";
   $o->{'sys'}->SetFilter({name=>$hostname});
   my @hl=$o->{'sys'}->getHashList(qw(id));
   if ($#hl==-1){
      msg(ERROR,"system $hostname not exists!");
      return(1);      
   }
   if ($#hl>0){
      msg(ERROR,"system $hostname not unique!");
      return(1);      
   }
   my $destid=$hl[0]->{id};
   $o->{'nas'}->SetFilter({systemid=>$destid});
   my @ln=$o->{'nas'}->getHashList(qw(id systemnfsnasserver name cistatusid
                                      type exportoptions systemnfsnas system ));
   foreach my $ln (@ln){
      my $found=0;
      foreach my $share (keys(%{$sharedata->{$hostname}})){
         if ($ln->{name} eq $share){
            $found=1;
         }
      } 
      if ($found == 0){
         push(@$oplist,{id         => $ln->{id},
                        cistatusid => 6,
                        export     => $ln->{name},
                        op         => 'delete'});
      }
   }
   foreach my $share (keys(%{$sharedata->{$hostname}})){
      my $ref;
      foreach my $ip (keys(%{$sharedata->{$hostname}->{$share}->{ip}})){
         my @r;
         foreach my $rights (keys(%{$sharedata->{$hostname}->{$share}->{ip}->{$ip}})){
               if ($sharedata->{$hostname}->{$share}->{ip}->{$ip}->{$rights} == 1){
                  push(@r,$rights);     
               }
         }
         $ref->{$ip}=join(",",@r);
      }
      foreach my $ln (@ln){
         if ($ln->{name} eq $share){
             $mode=$ln->{id};
         }
      }
      if ($mode eq "insert"){
         push(@$oplist,{id            => '',
                        op            => 'insert',
                        hostname      => $hostname,
                        export        => $share,
                        exportoptions => $sharedata->{$hostname}->{$share}->{'exportoptions'},
                        cistatusid    => 4,
                        ip            => $ref,
                        type          => $type});
      }elsif(defined($mode)){
          push(@$oplist,{id            => $mode,
                         op            => 'update',
                         hostname      => $hostname,
                         export        => $share,
                         exportoptions => $sharedata->{$hostname}->{$share}->{'exportoptions'},
                         cistatusid    => 4,
                         ip            => $ref,
                         type          => $type});
      }
   }
   return(0);
}


sub processOperations
{
   my $o=shift;    
   my $oplist=shift;    
   my ($networkid,$id);
   $o->{'net'}->SetFilter({name=>'T-Systems\ Storage/NAS\ LAN'});
   my @netid=$o->{'net'}->getHashList(qw(id));
   if (!($networkid=shift(@netid))){
      msg(ERROR,"no network id found");
      return(1);
   } 
   foreach my $rec (@$oplist){
      $id=undef;
      if ($rec->{'op'} eq 'insert'){
          $id=$o->{nas}->storeRecord({system        => $rec->{hostname},
                                      name          => $rec->{export},
                                      cistatusid    => $rec->{cistatusid},
                                      exportoptions => $rec->{exportoptions},
                                      type          => $rec->{type}});
          foreach my $ip (keys(%{$rec->{'ip'}})){
             my $stat=$o->{ipnet}->storeRecord({systemnfsnasid => $id,
                                                exportoptions  => $rec->{'ip'}->{$ip},
                                                networkid      => $networkid->{id},
                                                name           => $ip});
             if (!defined($stat)){
                msg(ERROR,"can't ".$rec->{op}." ip=".$ip);
                return(1);
             }
          } 
          msg(INFO,$rec->{op}." ".$rec->{export});
      }elsif($rec->{'op'} eq 'update'){
          $id=$o->{nas}->storeRecord({system        => $rec->{hostname},
                                      name          => $rec->{export},
                                      cistatusid    => $rec->{cistatusid},
                                      exportoptions => $rec->{exportoptions},
                                      type          => $rec->{type}},$rec->{id});
          $o->{'ipnet'}->SetFilter({systemnfsnasid=>$rec->{id}});
          my @ips=$o->{'ipnet'}->getHashList(qw(id));
          foreach my $ip (@ips){
             my $stat=$o->{ipnet}->deleteRecord($ip->{id});
             if (!defined($stat)){
                msg(ERROR,"can't delete ip=".$ip->{id});
                return(1);
             }
          }
          foreach my $ip (keys(%{$rec->{'ip'}})){
             my $stat=$o->{ipnet}->storeRecord({systemnfsnasid => $id,
                                                exportoptions  => $rec->{'ip'}->{$ip},
                                                networkid      => $networkid->{id},
                                                name           => $ip});
             if (!defined($stat)){
                msg(ERROR,"can't ".$rec->{op}." ip=".$ip);
                return(1);
             }
          } 
          msg(INFO,$rec->{op}." ".$rec->{export});
      }elsif($rec->{'op'} eq 'delete'){
          $id=$o->{nas}->storeRecord({cistatusid => $rec->{cistatusid}},$rec->{id});
      }else{
          msg(ERROR,"no operation mode");
          return(1);
      }
      if (!defined($id)){
         msg(ERROR,"can't ".$rec->{op}." record ".$rec->{export}." id=$id");
         return(1);
      }
   } 
}


my $flt=$ARGV[0];
if ($flt eq ""){
   msg(ERROR,"no filter specified");exit(3);
}


#######################################################################
sub Help
{
   print(<<EOF);
$RealScript [options] File File ...

   --verbose display more details of operation process
   --quiet   only errors would be displayed
   --base    base url of filemgmt (default: $DefaultBase)
   --webuser username
   --webpass password
   --store   stores the parameters (not help,verbose and store)
   --help    show this help

   --mode    emc, netapp, auto if no --mode
   --hostname seperate by comma
   --type    export type (nfs, cifs ...)
   --force    
EOF
}
#######################################################################
exit(255);
