#!/usr/bin/perl
#  W5Base Framework
#  Copyright (C) 2008  Holm Basedow (holm@blauwaerme.de)
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#

use strict;
use warnings;
use Data::Dumper;
use Date::Calc qw( Today_and_Now
                   Week_of_Year
                   Day_of_Week_to_Text
                   Delta_YMDHMS
                   Day_of_Week );
use IPC::Open3;
use IO::Handle;
use IO::Select;
use Compress::Zlib;
use Getopt::Long;
use Cwd;
use File::Path;
use POSIX;

my $st=[Today_and_Now()];
$Data::Dumper::Terse = 1;          
$Data::Dumper::Indent = 1;  
my @prog=qw(mysql mysqldump gunzip);
my($db,$prog,$err,$help,$exclude,$tasks,$convert,$file,$verbose,
   $format,$mode,$targetdb,$dir,%inputinclude,%inputexclude);
my $force=0;
# find progamms
foreach my $p (@prog){
   my $found=0;
   foreach my $path (split(/:/,$ENV{PATH})){
      if ( -x "$path/$p"){
         $found++;
         $prog->{$p}="$path/$p";
      }

   }
   die("programm $p not found") if (!$found);
}


# posible options
my $optresult = GetOptions ("help"        => \$help,
                            "exclude=s"   => \$exclude,
                            "dir=s"       => \$dir,
                            "file=s"      => \$file,
                            "tasks=i"     => \$tasks,
                            "mode=s"      => \$mode,
                            "targetdb=s"  => \$targetdb,
                            "force"       => \$force,
                            "verbose"     => \$verbose,
                            "format=s"    => \$format,
                            "convert=s"   => \$convert);

# print help message
sub help
{
   if ($help || (!$db && !$targetdb)){
      print <<EOF;
   Usage: mysqldump-ng [options] database [tables]
  
        --help         show this help
        --dir          directory to save dumps or import dumps,
                       (default current directory)
                       if you want to save one dump in more than one
                       directory you can seperate the directory names
                       with comma
        --file         file or files for import (seperat files by comma)
        --mode         export, import or transfer [default:export]
        --targetdb     is needed in transfermode transfer
        --tasks        number of tasks are be able running simultaneous [default:4]
        --exclude      tables excluded for dump (seperat tables by comma)
        --convert      save dump in spezial database format (InnoDB|MyISAM)
        --force        ignore warnings for example overwritting tables
        --verbose      write more output
        --format       defines the format of the dump folder (default: '\%db-\%Y-\%M-\%D-\%h:\%m')
                       if you save the dump in more than one folder, you can give various
                       formats seperat by comma
                       \%Y   Year
                       \%M   Month
                       \%D   Day
                       \%d   day of the week
                       \%h   hour
                       \%m   minute
                       \%s   second
                       \%w   week
                       \%db  database
EOF
      exit(1);                    
   }                              
}

sub dirformat
{
   my @dirformat; 
   my @dir;
   if ($format){
      @dir=split(/,/,$format);
   }
   my %format=(db=>$db);
   ($format{Y},$format{M},$format{D},
    $format{h},$format{m},$format{s})=Today_and_Now();
   ($format{w})=Week_of_Year($format{Y},$format{M},$format{D});
   ($format{d})=Day_of_Week_to_Text(Day_of_Week($format{Y},$format{M},$format{D}));
   foreach my $v (qw(h m s M D w)){
      $format{$v}=sprintf("%02d",$format{$v});
   }
   if (!@dir){
      push(@dir,"\%db-\%Y-\%M-\%D-\%h:\%m");
   }
   foreach my $d (@dir){
      foreach my $key (keys(%format)){
         $d=~s/\%$key/$format{$key}/;
      } 
      push(@dirformat,$d);
   }
   return(@dirformat);
}

sub msg
{
   my $type=shift;
   my $msg=shift;
   $msg=~s/%/%%/g if ($#_==-1);
   $msg=sprintf($msg,@_);
   return("") if (!$verbose and $type ne "ERROR");
   my $d;
   foreach my $linemsg (split(/\n/,$msg)){
      $d.=sprintf("%-6s %s\n",$type.":",$linemsg);
   }
   print STDERR $d;
   return($d);
}

sub check_db
{
   # db
   $db=$ARGV[0];
   shift(@ARGV);
 
   if (!$db){
      msg("ERROR","database not found!");
      exit(1);
   }
   # check database is usable
   if ($db and $mode ne "import"){
      local(*R, *E);
      open3(undef,*R,*E,"$prog->{mysql} $db");
      wait();
      if ($? != 0){
         msg("ERROR","source database $db not useable or not found, rc=".$?>>8);
         exit(1);
      }
      close(R);
    
      # clear mysql cache
      system("$prog->{mysql} -e 'flush logs' $db") == 0 
              or die("system command -mysql flush logs- failed:$?");
      system("$prog->{mysql} -e 'flush tables' $db") == 0 
              or die("system command -mysql flush tables- failed:$?");
   }
}

# check if database exists if not create the database
sub check_targetdb
{  
   my $tdb=shift;
   local(*R, *E);
   open3(undef,*R,*E,"$prog->{mysql} $tdb");
   wait();
   close(R);
   if ($? == 0){
      if ($force != 1){
         msg("ERROR","the target database=$tdb exists,
the database will be drop!!
Do you want continue? [y/N]: ");
         chomp(my $decision=<STDIN>);
         if (!(lc($decision) eq "yes" or lc($decision) eq "y")){
            msg("ERROR","abort by user");
            exit(1);
         }
            
      }
      local(*DROPERR);
      open3(undef,undef,*DROPERR,
            "$prog->{mysql} -e 'drop database $tdb;create database $tdb'");
      wait();
      if ($? != 0){
         msg("ERROR","database $tdb cannot drop! rc=".$?>>8);
         exit(1);
      }
      return(0);
   }
   local(*ER);
   open3(undef,undef,*ER,"$prog->{mysql} -e 'create database $tdb'");
   wait();
   if ($? != 0){
      msg("ERROR","database $tdb cannot create! rc=".$?>>8);
      exit(1);
   }
   close(ER);
   return(0);
}


# include tables
sub include_tables
{
   foreach my $data (@ARGV){
      my @tabary=split(/,/,$data);
      foreach my $ty (@tabary){
         $inputinclude{$ty}=0;
      }
   }
}

# exclude tables
sub exclude_tables
{
   if ($exclude){
      my @ex=split(/,/,$exclude);
      foreach my $data (@ex){
         $inputexclude{$data}=0;
      }
   }
}

# set directory
if (!$dir){
   $dir=cwd();
}

# set default simultaneous tasks
if (!$tasks){
   $tasks=4;
}

# set database type if convert set
if ($convert){
   if (lc($convert) eq "innodb"){
      $convert="InnoDB";
   }elsif(lc($convert) eq "myisam"){
      $convert="MyISAM";
   }else{
      msg("ERROR","unknow database format $convert only InnoDB or MyISAM");
      exit(1);
   }
}

# compare include and exclude tables are not the same
foreach my $in (keys(%inputinclude)){
   foreach my $ex (keys(%inputexclude)){
      if ($in eq $ex){
         msg("ERROR","some include and exclude tables are the same!");
         exit(1);
      }      
   }
}

sub load_tables{
   # load available tables in a array
   my $tabl=qx($prog->{mysql} -e 'show tables' $db) 
         or die ("system command -mysql show tables- failed:$?");
   my @tabl=split(/\n/,$tabl);
   shift(@tabl);
   return(@tabl);
}

# write tables to dump in a array
sub create_array_to_dump
{
   my @tabl=load_tables();
   my $found;
   my @tables;
   foreach my $tab (@tabl){
      if (%inputinclude){
         foreach my $data (keys(%inputinclude)){
            if ($data eq $tab){
               $inputinclude{$data}=1;
            }
         }
      }
      if (%inputexclude){
         foreach my $data (keys(%inputexclude)){
            if ($data eq $tab){
               $inputexclude{$data}=1;
            }
         }
      }
      push(@tables,$tab);
   }
   if (%inputinclude){
      @tables=();
      foreach my $data (keys(%inputinclude)){ 
         if ($inputinclude{"$data"} == 1){
            push(@tables,$data);
         }else{
            printf("ERROR: table $data not found\n");   
         }
      }
   }elsif(%inputexclude){
      @tables=();
      foreach my $tab (@tabl){
         $found=0;
         foreach my $data (keys(%inputexclude)){
            if ($data eq $tab and $inputexclude{"$data"} == 1){
               $found=1; 
            }
         }
         if ($found==0){
            push(@tables,$tab);
         }else{
            msg("INFO","table $tab excluded");
   
         }
      }
      foreach my $data (keys(%inputexclude)){
         if ($inputexclude{"$data"} == 0){
            printf("ERROR: table $data not found\n"); 
         }
      }
   } 
   return(@tables);
}

# plausibility-check for files in a dirctory 
sub check_dir
{
   my $dir=shift;
   my $found=0;
   my @path;
   foreach my $dir (@$dir){
      opendir(DIR,"$dir") or die("ERROR: directory $dir could not open!\n");
      my @files = grep {/^\w.*\.sql\.gz/}readdir(DIR);
      if (!@files){
         msg("ERROR","no *.sql.gz files in the $dir directory!");
         exit(1);
      }
      foreach my $file (@files){
         if ( -z "$dir/$file" ){
            $err->{$file}->[1]="$dir/$file the lenght of this file is zero!";                  
            $found=1;
         }
         push(@path,"$dir/$file");
      }
      closedir(DIR);
   }
   if ($found == 1){
      msg("ERROR",Dumper($err));
      exit(1);
   }
   return(@path);
}

# plausibility-check for files 
sub check_file
{
   my $file=shift;
   open(FH,"$file") or die("ERROR; file $file could not open!\n");
   if ( -z $file){
      msg("ERROR","the length of the file=$file is zero!");      
      exit(1);
   }
   close(FH);
   return(0);
}

sub process_engine
{ 
   my $tables=shift;
   my $dir=shift;
   my %processes;
   do 
   {
      foreach my $k (keys(%processes)){
         delete($processes{$k})  if (!kill(0,$k));
      }
      if (keys(%processes) < $tasks and @$tables){
         $SIG{CHLD}='IGNORE';  # parent don't wait on child exit state 
         my $pid=fork();
         if (not defined $pid) {
            die ("pid is not defined\n\n");
         } elsif ($pid == 0) {      # child process
           my $first=$tables->[0];
           $SIG{CHLD}='DEFAULT';
           # export database
           if ($mode eq "export"){
              my $mydsel=new IO::Select();
              my $mydrdr=new IO::Handle();
              my $myderr=new IO::Handle();
              my $convert_flag=0;
              my (@gz,@ready,@myderr,$wp,$save);
              my $mysqldump_pid=open3(undef,$mydrdr,$myderr,
                                     "$prog->{mysqldump} -q -c $db $first");
              $mydsel->add($myderr);

              # check for mysqldump errors
              @ready = $mydsel->can_read(0.5);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@myderr,$data);
                 }
              }
              # print mysqldump errors
              if ($#myderr != -1){
                 foreach my $fi (@myderr){
                    if ($fi){
                       msg("ERROR","$fi");
                    }
                 }
                 @ready=[];
              }else{
                 if ($convert){
                    msg("ERROR","convert engine is not supported for export");
                 }
              }

              foreach my $d (@$dir){
                  my $gz=gzopen("$d/$first.sql.gz", "w9")
                        or die "Cannot open file $d/$first.sql.gz: $gzerrno\n";
                  push(@gz,$gz);
              }
              while(my $line=<$mydrdr>){
                 foreach my $gz (@gz){
                    $gz->gzwrite("$line");
                 }
              }
              foreach my $gz (@gz){
                 $gz->gzclose();
              }
              close($mydrdr);
              $wp=waitpid($mysqldump_pid,0);
              $save=$?;
              if ($save != 0){
                 # print rc codes
                 msg("ERROR","system commmand mysqldump ".
                             "db=$db table=$first return a errorcode=$save");
                 msg("ERROR","mysqlprocess=$$ mysql_waitpid_return=$wp");
              }
              exit(0);
           #  import database
           }elsif ($mode eq "import"){
              my @ready;
              my @myerr;
              my @gunziperr;
              my $convert_flag=0;
              my ($wp,$save,$table);
              my $mysel=new IO::Select();
              my $gunzipsel=new IO::Select();
              my $mywtr=new IO::Handle();
              my $myerr=new IO::Handle();
              my $gunziprdr=new IO::Handle();
              my $gunziperr=new IO::Handle();
              my $gunzip_pid=open3(undef,$gunziprdr,$gunziperr,
                                   "$prog->{gunzip} -c $first");
              $gunzipsel->add($gunziperr);

              # check for gunzip errors
              @ready = $gunzipsel->can_read(0.1);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@gunziperr,$data);
                 }
              }
              # print gunzip errors
              if ($#gunziperr != -1){
                 foreach my $fi (@gunziperr){
                    if ($fi){
                       msg("ERROR","$fi");
                    }
                 }
                 @ready=[];
              }

              my $mysql_pid=open3($mywtr,undef,$myerr,"$prog->{mysql} $db ");
              $mysel->add($myerr);

              # check for mysql errors
              @ready = $mysel->can_read(0.5);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@myerr,$data);
                 }
              }
              # print mysql errors
              if ($#myerr != -1){
                 foreach my $fi (@myerr){
                    if ($fi){
                       msg("ERROR","$fi");
                    }
                 }
                 @ready=[];
              }

              msg("INFO","import $first");

              # database statments
              print $mywtr ("SET AUTOCOMMIT=0;\n");
              print $mywtr ("SET UNIQUE_CHECKS=0;\n");
              print $mywtr ("SET FOREIGN_KEY_CHECKS = 0;\n");
              while(my $line=<$gunziprdr>){
                 print $mywtr ("$line\n");                
                 if (!$table and $line=~m/^CREATE\s+TABLE.*\(/){
                    my @table=split('[ `]',$line);
                    $table=$table[3];
                 }
              }
              print $mywtr (";\n");                
              print $mywtr ("COMMIT;\n");
              # check for mysql errors
              @ready = $mysel->can_read(0.5);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@myerr,$data);
                 }
              }
              # check for gunzip errors
              @ready = $gunzipsel->can_read(0.1);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@gunziperr,$data);
                 }
              }
              # print mysql errors
              if ($#myerr != -1){
                 foreach my $fi (@myerr){
                    if ($fi){
                       msg("ERROR","$fi");
                    }
                 }
                 @ready=[];
              }
              # print gunzip errors
              if ($#gunziperr != -1){
                 foreach my $fi (@gunziperr){
                    if ($fi){
                       msg("ERROR","$fi");
                    }
                 }
                 @ready=[];
              }else{
                 if ($convert){
                    $|=1;
                    print $mywtr ("alter table $table engine=$convert;\n");
                    # check for alter table errors
                    @ready = $mysel->can_read(0.5);
                    foreach my $fh (@ready){
                       while (my $data=<$fh>){
                          push(@myerr,$data);
                       }
                    }
                    # print errors
                    if ($#myerr != -1){
                       foreach my $fi (@myerr){
                          if ($fi){
                             msg("ERROR","$fi");
                          }
                       }
                    }
                 }
              }
              close($gunziprdr);
              $wp=waitpid($gunzip_pid,0);
              $save=$?;
              if ($save != 0){
                 # print rc codes
                 msg("ERROR","system commmand gunzip ".
                             "file=$first return a errorcode=$save");
                 msg("ERROR","mysqlprocess=$$ mysql_waitpid_return=$wp");
              }
              close($mywtr);
              $wp=waitpid($mysql_pid,0);
              $save=$?;
              if ($save != 0){
                 # print rc codes
                 msg("ERROR","system commmand mysql ".
                     "db=$db file=$first return a errorcode=$save");
                 msg("ERROR","mysqlprocess=$$ mysql_waitpid_return=$wp");
              }
              exit(0);
           # transfer database
           }elsif($mode eq "transfer"){
              my $convert_flag=0;
              my @myerr;
              my @myderr;
              my @ready;
              my ($mysqldump_pid,$wp,$save);
              my $mysel=new IO::Select();
              my $mydumpsel=new IO::Select();
              my $myerr=new IO::Handle();
              my $mywtr=new IO::Handle();
              my $myderr=new IO::Handle();
              my $mydrdr=new IO::Handle();

              # open mysqldump handle
              $mysqldump_pid=open3(undef,$mydrdr,$myderr,
                                   "$prog->{mysqldump} $db $first");
              $mydumpsel->add($myderr);
             
              # check for mysqldump errors
              @ready = $mydumpsel->can_read(0.1);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@myderr,$data);
                 }
              }
              # print mysqldump errors
              if ($#myderr != -1){
                 foreach my $fi (@myderr){
                    if ($fi){
                       msg("ERROR","$fi");
                    }
                 }
                 @ready=[];
              }
               

              # open mysql handle
              my $mysql_pid=open3($mywtr,undef,$myerr,
                                  "$prog->{mysql} $targetdb");
              $mysel->add($myerr);
              # check for mysql errors
              @ready = $mydumpsel->can_read(0.5);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@myerr,$data);
                 }
              }
              # print mysql errors
              if ($#myerr != -1){
                 foreach my $fi (@myerr){
                    if ($fi){
                       msg("ERROR","$fi");
                    }
                 }
                 @ready=[];
              }
               
              msg("INFO","transfer $first");
       
              # write data to mysql handle
              print $mywtr ("SET AUTOCOMMIT=0;\n");
              print $mywtr ("SET UNIQUE_CHECKS=0;\n");
              print $mywtr ("SET FOREIGN_KEY_CHECKS = 0;\n");
              print $mywtr ("COMMIT;\n");

              while(my $line=<$mydrdr>){
                 print $mywtr ("$line\n"); 
              }
              print $mywtr (";\n");
              
              # check for mysqldump errors
              @ready = $mydumpsel->can_read(0.5);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@myerr,$data);
                 }
              }

              # check for mysql errors
              @ready = $mysel->can_read(0.5);
              foreach my $fh (@ready){
                 while (my $data=<$fh>){
                    push(@myerr,$data);
                 }
              }

              # print errors
              if ($#myerr != -1){
                 foreach my $fi (@myerr){
                    if ($fi){
                       msg("ERROR","$fi");
                    }
                 }
              }

              close($mydrdr);
              $wp=waitpid($mysqldump_pid,0);
              $save=$?;
              if ($save != 0){
                 # print rc codes
                 msg("ERROR","system command mysqldump ".
                     "db=$db table=$first return a errorcode=".$save>>8);
                 msg("ERROR","mysqlprocess=$$ mysql_waitpid_return=$wp");

              }else{
                 if ($convert){
                    $|=1;
                    print $mywtr ("alter table $first engine=$convert;\n");
                    # check for alter table errors
                    @ready = $mysel->can_read(0.5);
                    foreach my $fh (@ready){
                       while (my $data=<$fh>){
                          push(@myerr,$data);
                       }
                    }
                    # print errors
                    if ($#myerr != -1){
                       foreach my $fi (@myerr){
                          if ($fi){
                             msg("ERROR","$fi");
                          }
                       }
                    }
                 }
              }
              close($mywtr);
              $wp=waitpid($mysql_pid,0);
              $save=$?;
              if ($save != 0){
                 # print rc codes
                 msg("ERROR","system commmand mysql ".
                     "db=$targetdb table=$first return a errorcode=".$save>>8);
                 msg("ERROR","mysqlprocess=$$ mysql_waitpid_return=$wp");
              }
              exit(0);
            }
         } else {       # parent process
           $processes{$pid}=$tables->[0];
           shift(@$tables);      
         }
      }
      msg("INFO","count tables=$#{$tables} proccontent=".Dumper(\%processes));
      select(undef,undef,undef,0.5);
   }  
   until (keys(%processes) == 0 );
}

# test the mode or set default mode and run the engines
$mode="export" if (!$mode);
if (lc($mode) eq "export"){
   $mode="export";
   my $dircount=0;
   check_db();
   help();
   my @dirformat=dirformat();
   my @dir=split(/,/,$dir);
   my $dirformat;
   my @dircomplete;
   include_tables();
   exclude_tables();
   my @tab=create_array_to_dump();
   # create dump folder
   if ($#dir >= $#dirformat){
      foreach my $dir (@dir){
         if ($dirformat[$dircount]){
            $dirformat=$dirformat[$dircount];
         } 
         if (! -d "$dir/$dirformat"){
            mkdir("$dir/$dirformat") or 
                 die("create folder $dir/$dirformat failed!\n");
         }else{
            if ($force != 1){
               msg("ERROR","the folder $dir/$dirformat exists,
You really want to overite the folder? [y/N]: ");
            chomp(my $decision=<STDIN>);
               if (!(lc($decision) eq "yes" or lc($decision) eq "y")){
                  msg("ERROR","abort by user");
                  exit(1);
               }
            }
            rmtree("$dir/$dirformat");
            mkdir("$dir/$dirformat") or 
                  die("create folder $dir/$dirformat failed!\n");
         }
         push(@dircomplete,"$dir/$dirformat");
         $dircount++;
      }
   }else{
      foreach my $dirformat (@dirformat){
         if ($dir[$dircount]){
            $dir=$dir[$dircount]; 
         } 
         if (! -d "$dir/$dirformat"){
            mkdir("$dir/$dirformat") or 
                 die("create folder $dir/$dirformat failed!\n");
         }else{
            if ($force != 1){
               msg("ERROR","the folder $dir/$dirformat exists,
You really want to overite the folder? [y/N]: ");
            chomp(my $decision=<STDIN>);
               if (!(lc($decision) eq "yes" or lc($decision) eq "y")){
                  msg("ERROR","abort by user");
                  exit(1);
               }
            }
            rmtree("$dir/$dirformat");
            mkdir("$dir/$dirformat") or
                 die("create folder $dir/$dirformat failed!\n");
         }
         push(@dircomplete,"$dir/$dirformat");
         $dircount++;
      }
   }
   process_engine(\@tab,\@dircomplete);
   check_dir(\@dircomplete);
}elsif(lc($mode) eq "import"){
   $mode="import";
   my @files;
   check_db();
   help();
   check_targetdb($db);
   if ($db){
      if (!$file && $dir){
         my @dir=split(/,/,$dir);
         @files=check_dir(\@dir);
      }elsif($file){
         my @file=split(/,/,$file);
         foreach my $f (@file){
            check_file("$file");
            push(@files,$f);
         }
      }else{
         msg("ERROR","no files or directory for import!");
         exit(1);
      }
      process_engine(\@files,$dir);
   }else{
      msg("ERROR","$db not exists!");
      exit(1);
   }
}elsif(lc($mode) eq "transfer"){
   check_db();
   help();
   if ($targetdb){
      $mode="transfer";
      # check target db and source db not the same
      if ($targetdb eq $db){
         msg("ERROR","target database $targetdb ".
             "and source database $db the same!");
         exit(1);
      }
   }else{
      msg("ERROR","if mode=transfer option --targetdb must be set");
      exit(1);
   }
   include_tables();
   exclude_tables();
   my @tab=create_array_to_dump();
   check_targetdb($targetdb);
   process_engine(\@tab);
}else{
   msg("ERROR","unknow mode=$mode ".
       "only this modes import, export or transfer\n");
   exit(1);
}

my $et=[Today_and_Now()];
push(@$st,@$et);
my @take=Delta_YMDHMS(@$st);                         
printf ("INFO: the mysqldump-ng operation takes: %sh %smin %ssec\n"
        ,$take[3],$take[4],$take[5]);                         
                               
