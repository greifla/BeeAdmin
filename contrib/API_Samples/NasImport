#!/usr/bin/perl
use lib qw( /opt/w5base/lib);
use strict;                   
use W5Base::API;
use Data::Dumper;
use Fcntl qw(SEEK_SET);

my $DefaultBase="https://w5base.net/w5base/auth/";
my ($help,$verbose,$loginuser,$loginpass,$quiet,$base,$lang);
my ($mode,$force,$hostname,$type);
my %o;
my $count=0;
my %P=("help"=>\$help,"base=s"=>\$base,"lang=s"=>\$lang,
       "webuser=s"=>\$loginuser,"webpass=s"=> \$loginpass,
       "verbose+"=>\$verbose,
       "force"=>\$force,"hostname=s"=>\$hostname,
       "mode=s"=>\$mode,"type=s"=>\$type);
my @allowedmodes=qw(auto emc netapp);
my $optresult=XGetOptions(\%P,\&Help,undef,undef,".W5Base.Interface");

$mode="auto" if (!defined($mode));
$type="nfs" if (!defined($type));

my @hostname=split(/,/,$hostname);
if ($#ARGV != $#hostname){
   msg(ERROR,"number of files and hostnames must be the same!");
   exit(1);
}

#######################################################################
# create connection config
#
my $apidebug=$verbose>=3 ? 1 : 0;
my $Config=createConfig($base,$loginuser,$loginpass,$lang,$apidebug);
if (!defined($Config)){
   msg(ERROR,"base or username/password is not valid");exit(1);
}
else{
   msg(DEBUG,"create of config ok");
}
msg(DEBUG,"verbose=$verbose");


#
# Datenobjecte laden
#
#
#######################################################################
# load ModuleObject
#
my %loadobj=('sys'=>'itil::system',
             'nas'=>'itil::systemnfsnas',
             'ipnet'=>'itil::lnknfsnasipnet');
foreach my $localid (keys(%loadobj)){
   my $objectname=$loadobj{$localid};
   my $obj=getModuleObject($Config,$objectname);
   if (!defined($obj)){
      msg(ERROR,"can't load object $objectname");exit(2);
   }else{
      msg(DEBUG,"create of ModuleObject $objectname ok");
   }
   $o{$localid}=$obj;
}

foreach my $file (@ARGV){
   if (open(FILE,"<$file")){ 
      my $curmode=$mode;
      $curmode=detectMode(\*FILE) if ($mode eq "auto");
      msg(DEBUG,"curmode=$curmode");
      my %sharedata;
      my $result=readFile(\*FILE,\%sharedata,$curmode,$hostname[$count]);
      exit(1) if ($result != 0);
      my @oplist;
      my $result=calculateOperations(\%o,\%sharedata,\@oplist,$hostname[$count]); 
      exit(1) if ($result != 0);
      if ($force){
         my $result=processOperations(\%o,\@oplist);
         exit(1) if ($result != 0);
      }else{
         printf("fifi oplist=%s\n",Dumper(\@oplist)); 
      }
      close(FILE);
   }
   $count++;
}



sub detectMode
{
   my $fh=shift;
   my $mode;
   while(<$fh>){
      if ($_=~m/^export.*$/){
         $mode="emc";
      }elsif($_=~m/^.*sec=sys.*$/){
         $mode="netapp";
      }
   }
   return($mode);
}



sub readFile
{
   my $fh=shift;
   my $sharedata=shift;
   my $cm=shift;
   my $hostname=shift;
   seek($fh,SEEK_SET,0);
   while(my $line=<$fh>){
      $line=~s/\s*$//;
      $line=~s/#.*$//;
      if ($cm eq "emc"){
         next if ($line=~m/^\s*#.*$/);
         next if ($line=~m/^\s*$/);
         if (my ($path,$param)=$line=~m/^export\s+"([^"]+)"\s+(.*)\s*$/){
            my @param=split(/\s+/,$param); 
            foreach my $param (@param){
               if (my ($var,$ip)=$param=~m/^(\S+)=(.*)\s*$/){
                  foreach my $ip (split(/:/,$ip)){
                     if ($ip!~m/^.*[\/].*$/ and $ip=~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/){
                        $ip="$ip/32";
                     }
                     if (lc($var) eq "access" or lc($var) eq "rw" or lc($var) eq "root"){
                        $sharedata->{$hostname}->{$path}->{'ip'}->{$ip}->{$var}=1;
                     }else{
                        $sharedata->{$hostname}->{$path}->{$var}=$ip;
                     }
                  }
               }
               else{
                  msg(WARN,"param problem $param");
               }
            }
         }
         else{
            msg(WARN,$line);
         }
      }elsif($cm eq "netapp"){
         next if ($line=~m/^\s*#.*$/);
         next if ($line=~m/^\s*$/);
         if (my ($path,$param)=$line=~m/^(\/.*)\s+(.*)\s*$/){
            $param=~s/^-//;
            my @param=split(/,/,$param); 
            foreach my $param (@param){
               if (my ($var,$ip)=$param=~m/^(\S+)=(.*)\s*$/){
                  foreach my $ip (split(/:/,$ip)){
                     if ($ip!~m/^.*[\/].*$/ and $ip=~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/){
                        $ip="$ip/32";
                     }
                     if (lc($var) eq "access" or lc($var) eq "rw" or lc($var) eq "root"){
                        $sharedata->{$hostname}->{$path}->{'ip'}->{$ip}->{$var}=1;
                     }else{
                        $sharedata->{$hostname}->{$path}->{$var}=$ip;
                     }
                  }
               }
               else{
                  msg(WARN,"param problem $param");
               }
            }
         }
         else{
            msg(WARN,$line);
         }
      }
   }
   return(0);
}



sub calculateOperations
{
   my $o=shift;    
   my $sharedata=shift;    
   my $oplist=shift;    
   my $hostname=shift;    
   my $found;
printf STDERR ("fifi sharedata=%s\n",Dumper(\$sharedata));
   $o->{'sys'}->SetFilter({name=>$hostname});
   my @hl=$o->{'sys'}->getHashList(qw(id));
   if ($#hl==-1){
      msg(ERROR,"system $hostname not exists!");
      return(1);      
   }
   if ($#hl>0){
      msg(ERROR,"system $hostname not unique!");
      return(1);      
   }
   my $destid=$hl[0]->{id};
   $o->{'nas'}->SetFilter({systemid=>$destid});
   my @ln=$o->{'nas'}->getHashList(qw(id systemnfsnasserver name cistatusid
                                      type exportoptions systemnfsnas system ));
   if ($#ln==-1){
      foreach my $share (keys(%{$sharedata->{$hostname}})){ 
         push(@$oplist,{id         => '',
                        op         => 'insert',
                        hostname   => $hostname,
                        export     => $share,
                        cistatusid => '4',
                        type       => $type});
      }
   }
   foreach my $ln (@ln){
      $found=0;
      foreach my $share (keys(%{$sharedata->{$hostname}})){
         if ($ln->{name} eq $share){
            if ($ln->{type} eq $type and $ln->{cistatus} == 4){
               msg(INFO,"export ".$ln->{name}." exists. no changes!");
            }elsif($ln->{type} ne $type){
               msg(INFO,"export ".$ln->{name}.
                   " exists. only change the type from ".
                   $ln->{type}." to ".$type);
            }elsif($ln->{cistatus} != 4){
               msg(INFO,"export ".$ln->{name}.
                   " exists. only change the cistatus from ".
                   $ln->{cistatus}." to 4");
            }elsif($ln->{cistatus} != 4 and $ln->{type} ne $type){ 
               msg(INFO,"export ".$ln->{name}.
                   " exists. only change the cistatus,type from ".
                   $ln->{cistatus}." to 4 and ".$ln->{type}." to ".$type);
            }
            push(@$oplist,{id       => $ln->{id},
                           op       => 'update',
                           hostname => $hostname,
                           export   => $share,
                           cistatus => '4',
                           type     => $type});
            $found=1;
         }
      }
      if ($found == 0){
         msg(INFO,"add export ".$ln->{name});
         push(@$oplist,{id       => '',
                        op       => 'insert',
                        hostname => $hostname,
                        export   => $ln->{name},
                        cistatus => '4',
                        type     => $type});
      }
   }
   return(0);
}



sub processOperations
{
   my $o=shift;    
   my $oplist=shift;    
   my $id;
   foreach my $rec (@$oplist){
      $id=undef;
      if ($rec->{'op'} eq 'insert'){
          $id=$o->{nas}->storeRecord({system   => $rec->{hostname},
                                      name     => $rec->{export},
                                      cistatus => $rec->{cistatus},
                                      type     => $rec->{type}});
      }elsif($rec->{'op'} eq 'update'){
          $id=$o->{nas}->storeRecord({system   => $rec->{hostname},
                                      name     => $rec->{export},
                                      cistatus => $rec->{cistatus},
                                      type     => $rec->{type}},$rec->{id});
      }
      if ($id){
         msg(INFO,$rec->{op}." record ".$rec->{export}." id=$id");
      }else{
         msg(ERROR,"can't ".$rec->{op}." record ".$rec->{export}." id=$id");
         return(1);
      }
   } 
}










#sub read_file
#{
#   my $emc=0;
#   my $netapp=0;
#   my $data;
#   open(RDFILE,"<$file") or die("ERROR: open $file failed!");
#   while(my $rec=<RDFILE>){
#      if ($rec=~m/^export.*$/){
#         $emc=1;
#      }elsif($rec=~m/^.*sec=sys.*$/){
#         $netapp=1;
#      }
#   }
#   seek(RDFILE,SEEK_SET,0);
#   if ($emc == 1){
#      while(my $rec=<RDFILE>){
#         if ($rec=~m/^export.*$/){
#            my @dat=split(/\s+/,$rec); 
#            foreach my $dat (@dat){
#               $data->{$dat[1]}->{"rw"}->{$dat}="" if ($dat=~m/^rw=/); 
#               $data->{$dat[1]}->{"root"}->{$dat}="" if ($dat=~m/^root=/);
#               $data->{$dat[1]}->{"access"}->{$dat}="" if ($dat=~m/^access=/);
#            } 
#         }
#      }
#   }elsif($netapp == 1){
#
#   }else{
#      printf STDERR ("ERROR: file format unknown!\n");
#   }
#}

my $flt=$ARGV[0];
if ($flt eq ""){
   msg(ERROR,"no filter specified");exit(3);
}


#######################################################################
sub Help
{
   print(<<EOF);
$RealScript [options] File File ...

   --verbose display more details of operation process
   --quiet   only errors would be displayed
   --base    base url of filemgmt (default: $DefaultBase)
   --webuser username
   --webpass password
   --store   stores the parameters (not help,verbose and store)
   --help    show this help

   --mode    
   --hostname seperate by comma
   --type    export type (nfs, cifs ...)
   --force    
EOF
}
#######################################################################
exit(255);
