#!/usr/bin/env perl
package MyWin;
use strict;
use vars qw(@ISA);
use Data::Dumper;
@ISA=qw(Win32::GUI::Window);

sub new
{
   my $type=shift;
   my %param=@_;
   my $hostname=$param{-hostname};
   my $file=$param{ARGV}->[0];
   my $o=$param{o};
   my $force=$param{-force};
   $param{-left}=100;
   $param{-height}=500;
   $param{-width}=700;
   $param{-dialogui}=1;
   $param{-title}="test" if (!$param{-title});
   $param{-name}="Main";
   $param{-onResize}=\&doResize;
   $param{-onTerminate}=\&doTerminate;
   $param{-onMinimize}=\&doMinimize;
   eval("\$param{-menu}=Win32::GUI::MakeMenu(
                                     '&Datei' => 'Datei',
                                     ' > Öffnen'  => { -name=>'Open',-onClick=>\\&OpenFile},
                                     ' > B&eenden'  => { -name=>'Exit',-onClick=>\\&doTerminate},
                                     '&Test' =>{ -name=>'MyTest',-onClick=>\\&MyTest} ,
   );");
   my $self=$type->SUPER::new(%param);
   $self=bless($self,$type);
   $self->{file}=$file;
   $self->{o}=$o;
   $self->{force}=$force;
   $self->{GRID}=eval("apply Win32::GUI::GridLayout(\$self,[qw(10 * * * * 10)],
                                         [qw(10 20 20 20 10 40 10 20 10 * 10)],0,0);");
   $self->AddRadioButton(
           -name     => "auto",
           -text     => "Auto",
           -checked  => 1,
   );
   $self->{GRID}->add($self->auto,2,2,"justify justify");
   $self->AddRadioButton(
           -name     => "emc",
           -text     => "Emc"
   );
   $self->{GRID}->add($self->emc,2,3,"justify justify");
   $self->AddRadioButton(
           -name     => "netapp",
           -text     => "NetApp"
   );
   $self->{GRID}->add($self->netapp,2,4,"justify justify");
   $self->AddButton(
           -name   => "run",
           -text   => "Start",
           -onClick  => \&doStart, 
   );
   $self->{GRID}->add($self->run,[2..5],6,"justify justify");
   $self->AddLabel(
          -name   => "filename",
          -text   => $self->{file},
   );
   $self->{GRID}->add($self->filename,2,8,"justify justify");
   $self->AddLabel(
          -name   => "fileformat",
   );
   $self->{GRID}->add($self->fileformat,3,8,"justify justify");
   $self->AddLabel(
          -name   => "host",
   );
   $self->{GRID}->add($self->host,4,8,"justify justify");
   $self->AddLabel(
          -name   => "hostname",
          -text   => "Hostname",
   );
   $self->{GRID}->add($self->hostname,3,2,"justify justify");
   $self->AddTextfield(
           -name      => "hostname",
           -text      => $hostname,
   );
   $self->{GRID}->add($self->hostname, 3, 3, "justify justify");
   $self->AddTextfield(
           -name      => "output",
           -text      => "host",
           -multiline => 1,
   );
   $self->{GRID}->add($self->output, [2..5], 10, "justify justify");
   $self->checkMode();
   $self->{GRID}->recalc();
   return($self); 
}

sub OpenFile
{
   my $self=shift;
   my $file;
   eval('$file = Win32::GUI::GetOpenFileName();');
   $self->{file}=$file;
   $self->checkMode();
}

sub doStart
{
   my $self=shift;
   $self->{sharedata}={}; 
   my $mainwin=$self->GetParent;
   my $result=main::readFile($mainwin->{FH},
                             $self->{sharedata},
                             $mainwin->{curmode},
                             $mainwin->hostname->GetLine(0));
   exit(1) if ($result != 0);
   my @oplist; 
   my $result=main::calculateOperations($mainwin->{o},$self->{sharedata},
                                        \@oplist,$mainwin->hostname->GetLine(0));
   exit(1) if ($result != 0);
   if ($mainwin->{force}){
      $result=processOperations($mainwin->{o},\@oplist);
      exit(1) if ($result != 0);
   }
   my $text;
   foreach my $rec (@oplist){
      foreach my $key (keys(%{$rec})){
         $text=$text.$key."\t\t".$rec->{$key}."\r\n";
      }
   }
   $mainwin->output->Change(-text=>$text);

}

sub checkMode
{
   my $self=shift;
   my $file=$self->{file};
   if (open(FILE,"<$file")){
      $self->{curmode}=main::detectMode(\*FILE) if ($self->auto->GetCheck() == 1);
      $self->{curmode}="emc" if ($self->emc->GetCheck() == 1);
      $self->{curmode}="netapp" if ($self->netapp->GetCheck() == 1);
      $self->{FH}=\*FILE;
   }
   $self->{curmode}="unknown" if ($self->{curmode} == 1);
   $self->filename->Change(-text=>"DATEI: ".$file);
   $self->fileformat->Change(-text=>"FILEFORMAT: ".$self->{curmode});
   $self->host->Change(-text=>"HOSTNAME: ".$self->hostname->GetLine(0));
}

sub MyTest
{
   exit(0);
}

sub doTerminate
{
   return(-1);
}

sub doResize
{
   my $self=shift;
   $self->{GRID}->recalc();
}

sub doMinimize {
    return(0);
}


package main;
use lib qw(/opt/w5base/lib);
use strict;                   
use W5Base::API;
use Data::Dumper;
use Net::DNS;
use Fcntl qw(SEEK_SET);
use vars qw($GUI $Window);


my $DefaultBase="https://w5base.net/w5base/auth/";
my ($help,$verbose,$loginuser,$loginpass,$quiet,$base,$lang);
my ($mode,$force,$hostname,$type,$gui);
my %o;
my $count=0;
my %P=("help"=>\$help,"base=s"=>\$base,"lang=s"=>\$lang,
       "webuser=s"=>\$loginuser,"webpass=s"=> \$loginpass,
       "verbose+"=>\$verbose,
       "force"=>\$force,"hostname=s"=>\$hostname,
       "mode=s"=>\$mode,"type=s"=>\$type,"gui"=>\$gui);
my @allowedmodes=qw(auto emc netapp);
my $optresult=XGetOptions(\%P,\&Help,undef,undef,".W5Base.Interface");
my $netdns=new Net::DNS::Resolver();

$mode="auto" if (!defined($mode));
$type="nfs" if (!defined($type));

my @hostname=split(/,/,$hostname);
if ($#ARGV != $#hostname){
   exit(1);
}

# create connection config
my $apidebug=$verbose>=3 ? 1 : 0;
my $Config=createConfig($base,$loginuser,$loginpass,$lang,$apidebug);

# load ModuleObject
my %loadobj=('sys'=>'itil::system',
             'nas'=>'itil::systemnfsnas',
             'net'=>'itil::network',
             'ipnet'=>'itil::lnknfsnasipnet');
foreach my $localid (keys(%loadobj)){
   my $objectname=$loadobj{$localid};
   my $obj=getModuleObject($Config,$objectname);
   if (!defined($obj)){
   }else{
   }
   $o{$localid}=$obj;
}

gui();
exit;
sub gui
{
   if ($gui){
      $|=1;
      eval('use Win32::GUI;
            use Win32::GUI::GridLayout;
            $GUI=new MyWin(-title=>"NasImporter", 
                           -hostname=>$hostname,
                           ARGV=>\@ARGV,
                           o=>\%o,
                           -force=>$force);
            $GUI->Show();
            Win32::GUI::Dialog();');
      msg(ERROR,"--gui only in windows systems \n $@") if ($@);
   }
}
foreach my $file (@ARGV){
   if (open(FILE,"<$file")){ 
      my $curmode=$mode;
      $curmode=detectMode(\*FILE) if ($mode eq "auto");
      my %sharedata;
      my $result=readFile(\*FILE,\%sharedata,$curmode,$hostname[$count]);
      exit(1) if ($result != 0);
      my @oplist;
      $result=calculateOperations(\%o,\%sharedata,\@oplist,$hostname[$count]);
      exit(1) if ($result != 0);
      if ($force){
         $result=processOperations(\%o,\@oplist);
         exit(1) if ($result != 0);
      }else{
         foreach my $record (@oplist){
         }
      }
      close(FILE);
   }else{
      exit(1);
   }
   $count++;
}

sub detectMode
{
   my $fh=shift;
   my $mode;
   while(<$fh>){
      if ($_=~m/^export.*$/){
         $mode="emc";
         return($mode);
      }elsif($_=~m/^.*sec=sys.*$/){
         $mode="netapp";
         return($mode);
      }
   }
   msg(ERROR,"mode not exists");
   return(1);
}



sub readFile
{
   my $fh=shift;
   my $sharedata=shift;
   my $cm=shift;
   my $hostname=shift;
   seek($fh,SEEK_SET,0);
   while(my $line=<$fh>){
      $line=~s/\s*$//;
      $line=~s/#.*$//;
      next if ($line=~m/^\s*#.*$/);
      next if ($line=~m/^\s*$/);
      my ($path,$param,@param);
      if ($cm eq "netapp"){
         if (($path,$param)=$line=~m/^(\/.*)\s+(.*)\s*$/){
            $param=~s/^-//;
            @param=split(/,/,$param); 
         }else{
            msg(WARN,"line ignored: ".$line);
         }
      }elsif($cm eq "emc"){
         if (($path,$param)=$line=~m/^export\s+"([^"]+)"\s+(.*)\s*$/){
             @param=split(/\s+/,$param); 
         }else{
            msg(WARN,"line ignored: ".$line);
         }
      }
      foreach my $param (@param){
         if (my ($var,$ip)=$param=~m/^(\S+)=(.*)\s*$/){
            if (lc($var) ne "access" and lc($var) ne 
                         "rw" and lc($var) ne "root"){
               $sharedata->{$hostname}->{$path}->{'exportoptions'}="$ip=$var ";
               next;
            }
            foreach my $ip (split(/:/,$ip)){
               if ($ip!~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+.*$/){
                  my $query;
                  if ($query=$netdns->search($ip)){
                     foreach my $rr ($query->answer) {
                        next unless $rr->type eq "A";
                        $ip=$rr->address;
                     }
                  }else{
                     $sharedata->{$hostname}->{$path}->{'exportoptions'}=
                     $sharedata->{$hostname}->{$path}->{'exportoptions'}.
                     "$var=$ip ";
                     msg(WARN,"unknown IP/HOST=$ip, 
                               entry will be a export option!");
                     next;
                  }
               }
               if ($ip!~m/^.*[\/].*$/ and 
                   $ip=~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/){
                  $ip="$ip/32";
               }
               $sharedata->{$hostname}->{$path}->{'ip'}->{$ip}->{$var}=1;
            }
         }else{
            msg(WARN,"param problem $param line=$line");
         }
      }
   }
   return(0);
}


sub calculateOperations
{
   my $o=shift;    
   my $sharedata=shift;    
   my $oplist=shift;    
   my $hostname=shift;    
   my ($networkid,$found);

   # get hostname
   $o->{'sys'}->SetFilter({name=>$hostname});
   my @hl=$o->{'sys'}->getHashList(qw(id));
   if ($#hl==-1){
      msg(ERROR,"system $hostname not exists!");
      return(1);      
   }
   if ($#hl>0){
      msg(ERROR,"system $hostname not unique!");
      return(1);      
   }
  
   # get network 
   $o->{'net'}->SetFilter({name=>['T-Systems Storage/NAS LAN']});
   my @netid=$o->{'net'}->getHashList(qw(id));
   if ($#netid==-1){
      $o->{'sys'}->LastMsg();
  #    msg(ERROR,"network T-Systems Storage/NAS LAN not exists!");
      return(1);      
   }
   if ($#netid>0){
      $o->{'sys'}->LastMsg();
  #    msg(ERROR,"network T-Systems Storage/NAS LAN not unique!");
      return(1);      
   }

   # get available shares
   my $destid=$hl[0]->{id};
   $o->{'nas'}->SetFilter({systemid=>$destid});
   my @ln=$o->{'nas'}->getHashList(qw(id systemnfsnasserver name cistatusid
                                      type exportoptions systemnfsnas system));
   $o->{'nas'}->dieOnERROR();
   # set needless shares on delete state
   foreach my $ln (@ln){
      my $found=0;
      foreach my $share (keys(%{$sharedata->{$hostname}})){
         if ($ln->{name} eq $share){
            $found=1;
         }
      } 
      if ($found == 0){
          push(@$oplist,{OP           => 'update',
                         DATAOBJALIAS => 'nas',
                         IDENTIFYBY   => $ln->{id},
                         MSG          => "delete share ".$ln->{name},
                         DATA         => {cistatusid => 6}});
      }
   }

   foreach my $share (keys(%{$sharedata->{$hostname}})){
      my $ref;
      my $mode="insert";
      foreach my $ln (@ln){
         if ($ln->{name} eq $share){
            $mode="update";
            if ($ln->{cistatusid} != 4 or $ln->{type} ne $type){
               push(@$oplist,{OP           => 'update',
                              DATAOBJALIAS => 'nas',
                              IDENTIFYBY   => $ln->{id},
                              MSG          => "update $share on $hostname",
                              DATA         => {
                                type          => $type,
                                cistatusid    => 4,
                                hostname      => $hostname,
                                name          => $share}});
            }
            # get available ip's
            $o->{'ipnet'}->SetFilter({systemnfsnasid=>$ln->{id}});
            my @ni=$o->{'ipnet'}->getHashList(qw(id exportoptions 
                                              networkid systemnfsnasid name));
            $o->{'ipnet'}->dieOnERROR();
            # delete ip's on a existing share
            foreach my $ni (@ni){
               $found=0;
               foreach my $ip (keys(%{$sharedata->{$hostname}->
                                      {$share}->{ip}})){
                  if ($ni->{name} eq $ip){ 
                     $found=1;
                  } 
               }
               if ($found == 0){
                  push(@$oplist,{OP           => 'delete',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => $ni->{id},
                                 MSG          => "delete ip with id=$found",
                                 DATA         => {}});
               }
            }
            # update or insert ip's on a existing share
            foreach my $ip (keys(%{$sharedata->{$hostname}->{$share}->{ip}})){
               $found=0;
               my $options;
               foreach my $ni (@ni){
                  my @r;
                  foreach my $rights (keys(%{$sharedata->{$hostname}->
                                              {$share}->{ip}->{$ip}})){
                        if ($sharedata->{$hostname}->{$share}->
                                         {ip}->{$ip}->{$rights} == 1){
                           push(@r,$rights);     
                        }
                  }
                  $options=join(",",@r);
                  if ($ni->{name} eq $ip and ($ni->{networkid} ne $netid[0]->{id} or
                     $ni->{exportoptions} ne $options or 
                     $ni->{systemnfsnasid} ne $ln->{id})){
                      $found=$ni->{id};
                  }elsif($ni->{name} eq $ip){
                      $found=2;
                  }
               }
               if ($found == 0){
                  push(@$oplist,{OP           => 'insert',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => undef,
                                 MSG          => "insert ip $ip",
                                 DATA         => {
                                   systemnfsnasid  => $ln->{id},
                                   exportoptions   => $options,
                                   name            => $ip,
                                   networkid       => $netid[0]->{id}}});
               }elsif($found != 2){
                  push(@$oplist,{OP           => 'update',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => $found,
                                 MSG          => "update ip $ip",
                                 DATA         => {
                                   systemnfsnasid  => $ln->{id},
                                   exportoptions   => $options,
                                   name            => $ip,
                                   networkid       => $netid[0]->{id}}});
               }
            }
         }
      }
      # insert a new share
      if ($mode eq "insert"){
         my $newshare={OP           => 'insert',
                       DATAOBJALIAS => 'nas',
                       IDENTIFYBY   => undef,
                       MSG          => "insert $share on $hostname", 
                       DATA         => {
                         type          => $type,
                         cistatusid    => 4,
                         system        => $hostname,
                         name          => $share,
                         exportoptions => $sharedata->{$hostname}->{$share}->
                                          {'exportoptions'}}};
 
         push(@$oplist,$newshare);

         # insert a new ip on a new share
         my $options;
         foreach my $ip (keys(%{$sharedata->{$hostname}->{$share}->{ip}})){
            my @r;
            foreach my $rights (keys(%{$sharedata->{$hostname}->
                                       {$share}->{ip}->{$ip}})){
               if ($sharedata->{$hostname}->{$share}->{ip}->
                   {$ip}->{$rights} == 1){
                  push(@r,$rights);     
               }
            }
            $options=join(",",@r);
            push(@$oplist,{OP           => 'insert',
                           DATAOBJALIAS => 'ipnet',
                           IDENTIFYBY   => undef,
                           MSG          => "insert ip $ip on $hostname", 
                           DATA         => {
                             name            => $ip,
                             networkid       => $netid[0]->{id},
                             exportoptions   => $options,
                             systemnfsnasid  => \$newshare->{IDENTIFYBY}}});
         }
      }
   }
   return(0);
}


sub processOperations
{
   my $o=shift;    
   my $oplist=shift;    
   my ($id,$found);

   foreach my $record (@$oplist){
      # check for valid objects only
      foreach my $objname (keys(%{$record})){
         $found=0;
         foreach my $orgobjname (qw(DATAOBJALIAS OP MSG DATA IDENTIFYBY)){
            $found=1 if ($objname eq $orgobjname);
         }
         if ($found == 0){
            msg(ERROR,"Objectname=$objname not allowed");
            return(1);
         }
      }
      foreach my $data (keys(%{$record->{'DATA'}})){
         if (ref($record->{'DATA'}->{$data}) eq "SCALAR"){ 
            $record->{'DATA'}->{$data}=${$record->{'DATA'}->{$data}};
         }
      }
      if ($record->{OP} eq "insert"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->storeRecord($record->{'DATA'});
         $record->{'IDENTIFYBY'}=$id;
      }elsif($record->{OP} eq "update"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->storeRecord($record->{'DATA'},
                                                          $record->{'IDENTIFYBY'});
      }elsif($record->{OP} eq "delete"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->deleteRecord($record->{'IDENTIFYBY'});
      }else{
         msg(ERROR,"unvalid mode ".$record->{OP});
         return(1);
      }
      $o->{$record->{'DATAOBJALIAS'}}->dieOnERROR();
      msg(INFO,$record->{MSG});
   }
}


my $flt=$ARGV[0];
if ($flt eq ""){
   msg(ERROR,"no filter specified");exit(3);
}


# help menu
sub Help
{
   print(<<EOF);
$RealScript [options] File File ...

   --verbose  display more details of operation process
   --quiet    only errors would be displayed
   --base     base url of filemgmt [default:$DefaultBase]
   --webuser  username
   --webpass  password
   --store    stores the parameters (not help,verbose and store)
   --help     show this help
              
   --mode     emc, netapp, auto if no --mode [default:auto]
   --hostname more than one seperate by comma
   --type     export type (nfs, cifs ...) [default:nfs]
   --force    write data  
   --gui      grafical user interface
EOF
}

exit(255);
