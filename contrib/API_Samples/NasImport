#!/usr/bin/env perl
package MyWin;
use strict;
use vars qw(@ISA);
use Data::Dumper;
@ISA=qw(Win32::GUI::Window);

sub new
{
   my $type=shift;
   my %param=@_;
   my $hostname=$param{-hostname};
   my $file=$param{ARGV}->[0];
   my $o=$param{o};
   my $force=$param{-force};
   my $icon=eval("new Win32::GUI::Icon('icon_w5base.ico')");
   $param{-icon}=$icon;
   $param{-left}=100;
   $param{-height}=500;
   $param{-width}=700;
   $param{-dialogui}=1;
   $param{-title}="test" if (!$param{-title});
   $param{-name}="Main";
   $param{-onResize}=\&doResize;
   $param{-onTerminate}=\&doTerminate;
   $param{-onMinimize}=\&doMinimize;
   $param{-minsize}=[600,400];
   eval("\$param{-menu}=Win32::GUI::MakeMenu(
                                     '&File' => 'File',
                                     ' > &Open'  => { -name=>'Open',-onClick=>\\&OpenFile},
                                     ' > &End'  => { -name=>'Exit',-onClick=>\\&doTerminate},
                                     '&Test' =>{ -name=>'MyTest',-onClick=>\\&MyTest} ,
   );");
   my $self=$type->SUPER::new(%param);
   $self=bless($self,$type);
   $self->{file}=$file;
   $self->{o}=$o;
   $self->{ICON}=$icon;
   $self->AddNotifyIcon(-name => "systray",
                        -icon => $self->{ICON},
                        -tip  => "W5Base Importer",
   );
   $self->Center();
   $self->{GRID}=eval("apply Win32::GUI::GridLayout(\$self,[qw(10 * * * * * 10)],
                                         [qw(10 20 20 20 10 40 10 20 10 * 10)],0,0);");
   $self->AddRadioButton(
           -name     => "auto",
           -text     => "Auto",
           -checked  => 1,
   );
   $self->{GRID}->add($self->auto,2,2,"justify justify");
   $self->AddRadioButton(
           -name     => "emc",
           -text     => "Emc"
   );
   $self->{GRID}->add($self->emc,2,3,"justify justify");
   $self->AddRadioButton(
           -name     => "netapp",
           -text     => "NetApp"
   );
   $self->{GRID}->add($self->netapp,2,4,"justify justify");
   $self->AddCheckbox(
           -name     => "writedata",
           -text     => "write Data",
   );
   $self->{GRID}->add($self->writedata,3,4,"justify justify");
   $self->AddButton(
           -name   => "run",
           -text   => "Start",
           -onClick  => \&doStart, 
   );
   $self->{GRID}->add($self->run,[2..6],6,"justify justify");
   $self->AddLabel(
          -name   => "filename",
          -text   => $self->{file},
   );
   $self->{GRID}->add($self->filename,[2..4],8,"justify justify");
   $self->AddLabel(
          -name   => "fileformat",
   );
   $self->{GRID}->add($self->fileformat,5,8,"justify justify");
   $self->AddLabel(
          -name   => "host",
   );
   $self->{GRID}->add($self->host,6,8,"justify justify");
   $self->AddLabel(
          -name   => "hostname",
          -text   => "Hostname",
   );
   $self->{GRID}->add($self->hostname,4,2,"justify justify");
   $self->AddTextfield(
           -name      => "hostname",
           -text      => $hostname,
           -width     => 100,
           -height    => 20,
   );
   $self->{GRID}->add($self->hostname, 3, 2, "left");
   $self->AddTextfield(
           -name        => "output",
           -text        => "",
           -multiline   => 1,
           -readonly    => 1,
           -autohscroll => 1,
           -hscroll     => 1,
           -autovscroll => 1,
           -vscroll     => 1,
   );
   $self->{GRID}->add($self->output, [2..6], 10, "justify justify");
   $self->{GRID}->recalc();
   $self->writedata->SetCheck(1) if ($force);
   return($self); 
}

sub OpenFile
{
   my $self=shift;
   my $file;
   eval('$file = Win32::GUI::GetOpenFileName();');
   $self->{file}=$file;
   $self->checkMode();
}

sub doStart
{
   my $self=shift;
   my @oplist; 
   $self->{sharedata}={}; 
   my $mainwin=$self->GetParent();
   my @result=$mainwin->checkMode();
   if ($result[0] != 0){
      eval("Win32::MsgBox(\"\$result[1]\",Win32::MB_ICONQUESTION|0, 'Error!')"); 
      return(1,$result[1]);
   }
   @result=main::readFile($mainwin->{FH},
                          $self->{sharedata},
                          $mainwin->{curmode},
                          $mainwin->hostname->GetLine(0));
   if ($result[0] != 0){
      eval("Win32::MsgBox(\"\$result[1]\",Win32::MB_ICONQUESTION|0, 'Error!')");   
      return(1,$result[1]);
   }
   @result=main::calculateOperations($mainwin->{o},$self->{sharedata},
                                     \@oplist,$mainwin->hostname->GetLine(0));
   if ($result[0] != 0){
      eval("Win32::MsgBox(\"\$result[1]\",Win32::MB_ICONQUESTION|0, 'Error!')");   
      return(1,$result[1]);
   }
   if ($mainwin->writedata->GetCheck() == 1){
      @result=main::processOperations($mainwin->{o},\@oplist);
      if ($result[0] != 0){
         eval("Win32::MsgBox(\"\$result[1]\",Win32::MB_ICONQUESTION|0, 'Error!')");   
         return(1,$result[1]);
      }
   }
   my $text;
   foreach my $rec (@oplist){
      $text=$text.$rec->{MSG}."\r\n";
   }
   $mainwin->output->Change(-text=>$text);
}

sub checkMode
{
   my $self=shift;
   my $file=$self->{file};
   my @mode;
   $self->{curmode}="emc" if ($self->emc->GetCheck() == 1);
   $self->{curmode}="netapp" if ($self->netapp->GetCheck() == 1);
   if (open(FILE,"<$file")){
      if ($self->auto->GetCheck() == 1){
         @mode=main::detectMode(\*FILE) if ($self->auto->GetCheck() == 1);
      }
      $self->{FH}=\*FILE;
   }
   $self->filename->Change(-text=>"FILE: ".$file);
   $self->fileformat->Change(-text=>"FILEFORMAT: ".$self->{curmode});
   $self->host->Change(-text=>"HOSTNAME: ".$self->hostname->GetLine(0));
   if ($mode[0] != 0){
      $self->{curmode}="unknown";
      return(1,$mode[1]);
   }else{
      $self->{curmode}=$mode[1];
   }
   return(0);
}

sub MyTest
{
   exit(0);
}

sub doTerminate
{
   return(-1);
}

sub doOk
{
   return(-1);
}

sub doResize
{
   my $self=shift;
   $self->{GRID}->recalc();
}

sub doMinimize {
    return(1);
}


package main;
use lib qw(/opt/w5base/lib);
use strict;                   
use W5Base::API;
use Data::Dumper;
use Net::DNS;
use Fcntl qw(SEEK_SET);
use vars qw($GUI $Window);


my $DefaultBase="https://w5base.net/w5base/auth/";
my ($help,$verbose,$loginuser,$loginpass,$quiet,$base,$lang);
my ($mode,$force,$hostname,$type,$gui);
my %o;
my $count=0;
my %P=("help"=>\$help,"base=s"=>\$base,"lang=s"=>\$lang,
       "webuser=s"=>\$loginuser,"webpass=s"=> \$loginpass,
       "verbose+"=>\$verbose,
       "force"=>\$force,"hostname=s"=>\$hostname,
       "mode=s"=>\$mode,"type=s"=>\$type,"gui"=>\$gui);
my @allowedmodes=qw(auto emc netapp);
my $optresult=XGetOptions(\%P,\&Help,undef,undef,".W5Base.Interface");
my $netdns=new Net::DNS::Resolver();

$mode="auto" if (!defined($mode));
$type="nfs" if (!defined($type));

# create connection config
my $apidebug=$verbose>=3 ? 1 : 0;
my $Config=createConfig($base,$loginuser,$loginpass,$lang,$apidebug);

# load ModuleObject
my %loadobj=('sys'=>'itil::system',
             'nas'=>'itil::systemnfsnas',
             'net'=>'itil::network',
             'ipnet'=>'itil::lnknfsnasipnet');
foreach my $localid (keys(%loadobj)){
   my $objectname=$loadobj{$localid};
   my $obj=getModuleObject($Config,$objectname);
   if (!defined($obj)){
   }else{
   }
   $o{$localid}=$obj;
}

if ($gui){
   $|=1;
   eval('
         use Win32::GUI;
         use Win32::GUI::GridLayout;
         $GUI=new MyWin(-title=>"W5Base Importer", 
                        -hostname=>$hostname,
                        ARGV=>\@ARGV,
                        o=>\%o,
                        -force=>$force);
         $GUI->Show();
         Win32::GUI::Dialog();');
   msg(ERROR,"--gui only in windows systems \n $@") if ($@);
}else{
   my @hostname=split(/,/,$hostname);
   if ($#ARGV != $#hostname){
      exit(1);
   }

   foreach my $file (@ARGV){
      if (open(FILE,"<$file")){ 
         my @curmode=($mode);
         @curmode=detectMode(\*FILE) if ($mode eq "auto");
         msg(ERROR,$curmode[1]); exit(1) if ($curmode[0] != 0);
         my %sharedata;
         my @result=readFile(\*FILE,\%sharedata,$curmode[0],$hostname[$count]);
         msg(ERROR,$result[1]); exit(1) if ($result[0] != 0);
         my @oplist;
         @result=calculateOperations(\%o,\%sharedata,\@oplist,$hostname[$count]);
         msg(ERROR,$result[1]); exit(1) if ($result[0] != 0);
         if ($force){
            @result=processOperations(\%o,\@oplist);
            msg(ERROR,$result[1]); exit(1) if ($result[0] != 0);
         }else{
            foreach my $rec (@oplist){
               msg(INFO,$rec->{MSG});
            }
         }
         close(FILE);
      }else{
         exit(1);
      }
      $count++;
   }
}

sub detectMode
{
   my $fh=shift;
   my $mode;
   while(<$fh>){
      if ($_=~m/^export.*$/){
         $mode="emc";
         return(0,$mode);
      }elsif($_=~m/^.*sec=sys.*$/){
         $mode="netapp";
         return(0,$mode);
      }
   }
   return(1,"mode not exists");
}



sub readFile
{
   my $fh=shift;
   my $sharedata=shift;
   my $cm=shift;
   my $hostname=shift;
   seek($fh,SEEK_SET,0);
   $sharedata->{$hostname}->{'ignore'}=[];
   while(my $line=<$fh>){
      $line=~s/\s*$//;
      $line=~s/#.*$//;
      next if ($line=~m/^\s*#.*$/);
      next if ($line=~m/^\s*$/);
      my ($path,$param,@param);
      if ($cm eq "netapp"){
         if (($path,$param)=$line=~m/^(\/.*)\s+(.*)\s*$/){
            $param=~s/^-//;
            @param=split(/,/,$param); 
         }else{
            push(@{$sharedata->{$hostname}->{'ignore'}},"WARN: line ignored: $line");
         }
      }elsif($cm eq "emc"){
         if (($path,$param)=$line=~m/^export\s+"([^"]+)"\s+(.*)\s*$/){
             @param=split(/\s+/,$param); 
         }else{
            push(@{$sharedata->{$hostname}->{'ignore'}},"WARN: line ignored: $line");
         }
      }
      foreach my $param (@param){
         if (my ($var,$ip)=$param=~m/^(\S+)=(.*)\s*$/){
            if (lc($var) ne "access" and lc($var) ne 
                         "rw" and lc($var) ne "root"){
               $sharedata->{$hostname}->{$path}->{'exportoptions'}="$ip=$var ";
               next;
            }
            foreach my $ip (split(/:/,$ip)){
               if ($ip!~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+.*$/){
                  my $query;
                  if ($query=$netdns->search($ip)){
                     foreach my $rr ($query->answer) {
                        next unless $rr->type eq "A";
                        $ip=$rr->address;
                     }
                  }else{
                     $sharedata->{$hostname}->{$path}->{'exportoptions'}=
                     $sharedata->{$hostname}->{$path}->{'exportoptions'}.
                     "$var=$ip ";
                     push(@{$sharedata->{$hostname}->{'ignore'}},
                     "WARN: unknown IP/HOST=$ip, entry will be a export option!");
                     next;
                  }
               }
               if ($ip!~m/^.*[\/].*$/ and 
                   $ip=~m/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/){
                  $ip="$ip/32";
               }
               $sharedata->{$hostname}->{$path}->{'ip'}->{$ip}->{$var}=1;
            }
         }else{
            push(@{$sharedata->{$hostname}->{'ignore'}},
            "WARN: param problem $param line=$line");
         }
      }
   }
   return(0);
}


sub calculateOperations
{
   my $o=shift;    
   my $sharedata=shift;    
   my $oplist=shift;    
   my $hostname=shift;    
   my ($networkid,$found);

   # get hostname
   $o->{'sys'}->SetFilter({name=>$hostname});
   my @hl=$o->{'sys'}->getHashList(qw(id));
   if ($#hl==-1){
      return(1,"system $hostname not exists!");      
   }
   if ($#hl>0){
      return(1,"system $hostname not unique!");      
   }
  
   # get network 
   $o->{'net'}->SetFilter({name=>['T-Systems Storage/NAS LAN']});
   my @netid=$o->{'net'}->getHashList(qw(id));
   if ($#netid==-1){
      $o->{'sys'}->LastMsg();
      return(1,"network T-Systems Storage/NAS LAN not exists!");      
   }
   if ($#netid>0){
      $o->{'sys'}->LastMsg();
      return(1,"network T-Systems Storage/NAS LAN not unique!");      
   }

   # get available shares
   my $destid=$hl[0]->{id};
   $o->{'nas'}->SetFilter({systemid=>$destid});
   my @ln=$o->{'nas'}->getHashList(qw(id systemnfsnasserver name cistatusid
                                      type exportoptions systemnfsnas system));
   $o->{'nas'}->dieOnERROR();
   # set needless shares on delete state
   foreach my $ln (@ln){
      my $found=0;
      foreach my $share (keys(%{$sharedata->{$hostname}})){
         if ($ln->{name} eq $share){
            $found=1;
         }
      } 
      if ($found == 0){
          push(@$oplist,{OP           => 'update',
                         DATAOBJALIAS => 'nas',
                         IDENTIFYBY   => $ln->{id},
                         MSG          => "delete share ".$ln->{name},
                         DATA         => {cistatusid => 6}});
      }
   }

   foreach my $share (keys(%{$sharedata->{$hostname}})){
      my $mode="insert";
      if ($share eq "ignore"){
         foreach my $ig (@{$sharedata->{$hostname}->{'ignore'}}){
            push(@$oplist,{OP  => 'ignore',
                           MSG => $ig});
         }
         $mode="ignore";
      }
      my $ref;
      foreach my $ln (@ln){
         if ($ln->{name} eq $share){
            $mode="update";
            if ($ln->{cistatusid} != 4 or $ln->{type} ne $type){
               push(@$oplist,{OP           => 'update',
                              DATAOBJALIAS => 'nas',
                              IDENTIFYBY   => $ln->{id},
                              MSG          => "update $share on $hostname",
                              DATA         => {
                                type          => $type,
                                cistatusid    => 4,
                                hostname      => $hostname,
                                name          => $share}});
            }
            # get available ip's
            $o->{'ipnet'}->SetFilter({systemnfsnasid=>$ln->{id}});
            my @ni=$o->{'ipnet'}->getHashList(qw(id exportoptions 
                                              networkid systemnfsnasid name));
            $o->{'ipnet'}->dieOnERROR();
            # delete ip's on a existing share
            foreach my $ni (@ni){
               $found=0;
               foreach my $ip (keys(%{$sharedata->{$hostname}->
                                      {$share}->{ip}})){
                  if ($ni->{name} eq $ip){ 
                     $found=1;
                  } 
               }
               if ($found == 0){
                  push(@$oplist,{OP           => 'delete',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => $ni->{id},
                                 MSG          => "delete ip with id=$found",
                                 DATA         => {}});
               }
            }
            # update or insert ip's on a existing share
            foreach my $ip (keys(%{$sharedata->{$hostname}->{$share}->{ip}})){
               $found=0;
               my $options;
               foreach my $ni (@ni){
                  my @r;
                  foreach my $rights (keys(%{$sharedata->{$hostname}->
                                              {$share}->{ip}->{$ip}})){
                        if ($sharedata->{$hostname}->{$share}->
                                         {ip}->{$ip}->{$rights} == 1){
                           push(@r,$rights);     
                        }
                  }
                  $options=join(",",@r);
                  if ($ni->{name} eq $ip and ($ni->{networkid} ne $netid[0]->{id} or
                     $ni->{exportoptions} ne $options or 
                     $ni->{systemnfsnasid} ne $ln->{id})){
                      $found=$ni->{id};
                  }elsif($ni->{name} eq $ip){
                      $found=2;
                  }
               }
               if ($found == 0){
                  push(@$oplist,{OP           => 'insert',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => undef,
                                 MSG          => "insert ip $ip",
                                 DATA         => {
                                   systemnfsnasid  => $ln->{id},
                                   exportoptions   => $options,
                                   name            => $ip,
                                   networkid       => $netid[0]->{id}}});
               }elsif($found != 2){
                  push(@$oplist,{OP           => 'update',
                                 DATAOBJALIAS => 'ipnet',
                                 IDENTIFYBY   => $found,
                                 MSG          => "update ip $ip",
                                 DATA         => {
                                   systemnfsnasid  => $ln->{id},
                                   exportoptions   => $options,
                                   name            => $ip,
                                   networkid       => $netid[0]->{id}}});
               }
            }
         }
      }
      # insert a new share
      if ($mode eq "insert"){
         my $newshare={OP           => 'insert',
                       DATAOBJALIAS => 'nas',
                       IDENTIFYBY   => undef,
                       MSG          => "insert $share on $hostname", 
                       DATA         => {
                         type          => $type,
                         cistatusid    => 4,
                         system        => $hostname,
                         name          => $share,
                         exportoptions => $sharedata->{$hostname}->{$share}->
                                          {'exportoptions'}}};
 
         push(@$oplist,$newshare);

         # insert a new ip on a new share
         my $options;
         foreach my $ip (keys(%{$sharedata->{$hostname}->{$share}->{ip}})){
            my @r;
            foreach my $rights (keys(%{$sharedata->{$hostname}->
                                       {$share}->{ip}->{$ip}})){
               if ($sharedata->{$hostname}->{$share}->{ip}->
                   {$ip}->{$rights} == 1){
                  push(@r,$rights);     
               }
            }
            $options=join(",",@r);
            push(@$oplist,{OP           => 'insert',
                           DATAOBJALIAS => 'ipnet',
                           IDENTIFYBY   => undef,
                           MSG          => "insert ip $ip on $hostname", 
                           DATA         => {
                             name            => $ip,
                             networkid       => $netid[0]->{id},
                             exportoptions   => $options,
                             systemnfsnasid  => \$newshare->{IDENTIFYBY}}});
         }
      }
   }
   return(0);
}


sub processOperations
{
   my $o=shift;    
   my $oplist=shift;    
   my ($id,$found);
   foreach my $record (@$oplist){
      # check for valid objects only
      foreach my $objname (keys(%{$record})){
         $found=0;
         foreach my $orgobjname (qw(DATAOBJALIAS OP MSG DATA IDENTIFYBY)){
            $found=1 if ($objname eq $orgobjname);
         }
         if ($found == 0){
            return(1,"Objectname=$objname not allowed");
         }
      }
      foreach my $data (keys(%{$record->{'DATA'}})){
         if (ref($record->{'DATA'}->{$data}) eq "SCALAR"){ 
            $record->{'DATA'}->{$data}=${$record->{'DATA'}->{$data}};
         }
      }
      if ($record->{OP} eq "insert"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->storeRecord($record->{'DATA'});
         $record->{'IDENTIFYBY'}=$id;
      }elsif($record->{OP} eq "update"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->storeRecord($record->{'DATA'},
                                                          $record->{'IDENTIFYBY'});
      }elsif($record->{OP} eq "delete"){
         $id=$o->{$record->{'DATAOBJALIAS'}}->deleteRecord($record->{'IDENTIFYBY'});
      }else{
         if ($record->{OP} ne "ignore"){
            return(1,"unvalid mode ".$record->{OP});
         }
      }
   }
}


my $flt=$ARGV[0];
if ($flt eq ""){
   msg(ERROR,"no filter specified");exit(3);
}


# help menu
sub Help
{
   print(<<EOF);
$RealScript [options] File File ...

   --verbose  display more details of operation process
   --quiet    only errors would be displayed
   --base     base url of filemgmt [default:$DefaultBase]
   --webuser  username
   --webpass  password
   --store    stores the parameters (not help,verbose and store)
   --help     show this help
              
   --mode     emc, netapp, auto if no --mode [default:auto]
   --hostname more than one seperate by comma
   --type     export type (nfs, cifs ...) [default:nfs]
   --force    write data  
   --gui      grafical user interface
EOF
}

exit(255);
